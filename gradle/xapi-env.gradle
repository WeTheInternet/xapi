import java.util.function.Function

// This is a special file, which is designed to be included from many places.
// We will install some extensions into the project,
// like the location of the $xapiRoot directory,
// or some Function objects you can invoke to perform simple tasks.

// If you copy-paste this file, do not name it xapi-env,
// unless you are fine with having your source code treated like it was the xapi repository.



// Find xapiHome, and set it as an extension.

def xapiHome = findProperty('xapi.home')
if (!xapiHome) {
    // look in the root project, to avoid expensive horsing around.
    def root = rootProject.findProperty('xapi.home')
    if (root) {
        extensions.add('xapi.home', xapiHome = root)
    } else {
        Set<File> maybe = [xapiHome = rootDir]
        while (!maybe.isEmpty()) {
            Iterator<File> itr = maybe.iterator()
            File search = itr.next()
            itr.remove()
            while (search != null) {
                File f = new File(search, 'gradle/xapi-env.gradle')
                if (f.exists()) {
                    xapiHome = search
                    maybe.clear()
                    break
                }
                f = new File(search, 'xapi')
                if (f.exists()) {
                    maybe.add(new File(search, 'xapi'))
                }
                search = search.parentFile
            }
        }
        extensions.add('xapi.home', xapiHome.absolutePath)
        // if rootProject already had it, we would never get to this block of code
        if (project != rootProject) {
            rootProject.extensions.add('xapi.home', xapiHome.absolutePath)
        }
    }
}

if (System.getProperty('xapiIntoBuildscript') == 'true') {
    System.clearProperty('xapiIntoBuildscript')
    // TODO: check into the behavior of buildSrc in composites (relative to the rootProject; can buildSrc see composite root buildSrc?)
    logger.quiet "Adding to xapi buildscript $project.path"
    ScriptHandler b = project.extensions.findByName('myBuildscript') ?: project.buildscript
    if (b.configurations.getByName('classpath').state != Configuration.State.UNRESOLVED) {
        throw new IllegalStateException("-DxapiIntoBuildscript=true, but build script already resolved when xapi-env.gradle was applied;\n" +
                "You need to apply xapi-env within the buildscript {} closure")
    }
    b.repositories.maven {
        name = 'xapiLocal'
        url = new File(xapiHome.toString(), 'repo').toURI().toURL()
        metadataSources { sources ->
                // The xapiLocal *for buildscript* will require 100% gradleMetadata dependencies.
                // This is possible because our tools have zero external dependencies, and are built from this repo.
                sources.gradleMetadata()
        }
    }
//    b.dependencies.add 'classpath', 'net.wti.gradle.tools:xapi-gradle-tools:0.5.1'
}

if (!extensions.findByName('installRebuild')) {
    // Install a rebuild task, only suitable for use in buildSrc
    Function<String, Task> installRebuild = {
        String mod ->

            boolean xapiChanging = 'true' == System.getProperty('xapi.changing') ||
                                    'true' == findProperty('xapi.changing')
            if (!xapiChanging) {
                return null
            }
            if (rootDir.name != 'buildSrc') {
                logger.error "installRebuild tasks should only be installed into buildSrc, not $rootDir"
            }
            plugins.apply 'java'

            def buildPlugin = tasks.create "buildProject_${mod.replace('.' as char, '_' as char)}", GradleBuild, {
                GradleBuild b ->
                    b.dir = new File(xapiHome.toString(), "$mod".toString())
                    b.tasks = ['build']
                    b.startParameter.excludedTaskNames = ['test']
                    b.startParameter.parallelProjectExecutionEnabled = true
                    b.startParameter.buildCacheEnabled = true
                    // whatever buildSrc is creating these "build other gradle worlds"
                    // will be in charge of adding _all_ desired rebuilds;
                    // we will not attempt to deal with cascading rebuilds.
                    b.startParameter.projectProperties << ['xapi.changing' : 'false', 'xapi.composite': 'false']
                    b.onlyIf {
                        boolean build = xapiChanging && 'true' != System.getProperty("xapi.built.$mod")
                        if (build) {
                            logger.quiet "Adding composite $b.dir"
                        }
                        return build
                    }
                    b.doFirst {
                        System.setProperty("xapi.built.$mod", 'true')
                    }
            }

            tasks.getByName(JavaPlugin.COMPILE_JAVA_TASK_NAME).dependsOn buildPlugin
            tasks.getByName(BasePlugin.ASSEMBLE_TASK_NAME).dependsOn buildPlugin
            return buildPlugin
    }
    extensions.add('installRebuild', installRebuild)
}


if (!findProperty('xapiVersion')) {
    extensions.add('xapiVersion', '0.5.1')
}
if (version == 'unspecified') {
    version = findProperty('xapiVersion')
}

RepositoryHandler repos = repositories
afterEvaluate {
    if (!repos.findAll({ it.name == 'xapiLocal'})) {
        repos.maven {
            name = 'xapiLocal'
            url = new File(xapiHome.toString(), 'repo')
        }
    }
}

if (extensions.findByName('buildsPresent') == null) {
    // TODO: make this lazily resolved
    LinkedHashMap<String, IncludedBuild> buildsPresent = [:]
    gradle.includedBuilds.each {
        IncludedBuild b ->
            buildsPresent.put(b.name, b)
    }
    extensions.add('buildsPresent', buildsPresent)
}
