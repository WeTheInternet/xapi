/*
 * Copyright (C) 2007-2010 JÃºlio Vilmar Gesser.
 * Copyright (C) 2011, 2013-2015 The JavaParser Team.
 * Copyright (C) 2016+ We The Internet.
 *
 * This file is originally based upon the JavaParser project.
 * Original license terms below:
 *
 * JavaParser can be used either under the terms of
 * a) the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * b) the terms of the Apache License
 *
 * You should have received a copy of both licenses in LICENCE.LGPL and
 * LICENCE.APACHE. Please refer to those files for details.
 *
 * JavaParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * // End original license
 *
 * This grammar file has been modified to provide enhancements to standard java syntax,
 * along with some utilities to provide delegate and scoped visitors.
 *
 * The original package is maintained so we can send enhancements upstream,
 * with enhancement-specific services exposed via the xapi.lang.X_Lang class.
 *
 */
options {
  LOOKAHEAD=1;
  STATIC=false;
  JAVA_UNICODE_ESCAPE=false;
  COMMON_TOKEN_ACTION=true;
  //SUPPORT_CLASS_VISIBILITY_PUBLIC=false;
//  TOKEN_MANAGER_USES_PARSER = true;
  JDK_VERSION = "1.6";
  TOKEN_FACTORY = "ASTParser.GTToken";

  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  // TODO enable this and adapt to the updated output format
//  JAVA_TEMPLATE_TYPE = "modern";
}

PARSER_BEGIN(ASTParser)
/*
 *
 * This file is part of Java 1.8 parser and Abstract Syntax Tree.
 *
 * Java 1.8 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Java 1.8 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.github.javaparser;

import java.io.*;
import java.util.*;
import com.github.javaparser.ast.*;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.comments.*;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.ast.stmt.*;
import com.github.javaparser.ast.type.*;

/**
 * <p>This class was generated automatically by javacc, do not edit.</p>
 */
final class ASTParser {

    void reset(InputStream in, String encoding) {
        ReInit(in, encoding);
    }

    private List add(List list, Object obj) {
    	if (list == null) {
    		list = new LinkedList();
    	}
    	list.add(obj);
    	return list;
    }

    private List add(int pos, List list, Object obj) {
    	if (list == null) {
    		list = new LinkedList();
    	}
    	list.add(pos, obj);
    	return list;
    }

	private class Modifier {

		final int modifiers;
		final List annotations;
		final int beginLine;
		final int beginColumn;

		public Modifier(int beginLine, int beginColumn, int modifiers, List annotations) {
			this.beginLine = beginLine;
			this.beginColumn = beginColumn;
			this.modifiers = modifiers;
			this.annotations = annotations;
		}
	}

    public int addModifier(int modifiers, int mod, Token token) throws ParseException {
        if ((ModifierSet.hasModifier(modifiers, mod))) {
            throwParseException(token, "Duplicated modifier");
        }
        return ModifierSet.addModifier(modifiers, mod);
    }

    private void throwParseException(Token token, String message) throws ParseException {
        StringBuilder buf = new StringBuilder();
        buf.append(message);
        buf.append(": '");
        buf.append(token.image);
        buf.append("' at line ");
        buf.append(token.beginLine);
        buf.append(", column ");
        buf.append(token.beginColumn);
        ParseException e = new ParseException(buf.toString());
        e.currentToken = token;
        throw e;
    }

    private Expression generateLambda(Expression ret, Statement lambdaBody) throws ParseException {
	    if (ret instanceof EnclosedExpr) {
	        Expression inner = ((EnclosedExpr) ret).getInner();
	        if (inner != null && inner instanceof NameExpr) {
	            VariableDeclaratorId id = new VariableDeclaratorId(inner.getBeginLine(), inner.getBeginColumn(), inner.getEndLine(), inner.getEndColumn(), ((NameExpr)inner).getName(), 0);
	       	    List params = add(null, new Parameter(ret.getBeginLine(), ret.getBeginColumn(), ret.getEndLine(), ret.getEndColumn(), 0, null, new UnknownType(), false, id));
	            ret = new LambdaExpr(ret.getBeginLine(), ret.getBeginColumn(), lambdaBody.getEndLine(), lambdaBody.getEndColumn(), params, lambdaBody, true);
	        } else {
	            ret = new LambdaExpr(ret.getBeginLine(), ret.getBeginColumn(), lambdaBody.getEndLine(), lambdaBody.getEndColumn(), null, lambdaBody, true);
	        }
	    } else if (ret instanceof NameExpr) {
		    VariableDeclaratorId id = new VariableDeclaratorId(ret.getBeginLine(), ret.getBeginColumn(), ret.getEndLine(), ret.getEndColumn(), ((NameExpr)ret).getName(), 0);
	        List params = add(null, new Parameter(ret.getBeginLine(), ret.getBeginColumn(), ret.getEndLine(), ret.getEndColumn(), 0, null, new UnknownType(), false, id));
	        ret = new LambdaExpr(ret.getBeginLine(), ret.getBeginColumn(), ret.getEndLine(), ret.getEndColumn(), params, lambdaBody, false);
	    } else if (ret instanceof LambdaExpr) {
	        ((LambdaExpr) ret).setBody(lambdaBody);
	        ret.setEndLine(lambdaBody.getEndLine());
	        ret.setEndColumn(lambdaBody.getEndColumn());
	    } else {
	        throw new ParseException("Failed to parse lambda expression! Please create an issue at https://github.com/javaparser/javaparser/issues");
	    }
	    return ret;
    }

    private TypeArguments createTypeArguments(List<Type> typeArgs) {
        boolean usesDiamondOperator = typeArgs != null && typeArgs.isEmpty();
        return usesDiamondOperator ? TypeArguments.withDiamondOperator() : TypeArguments.withArguments(typeArgs);
    }

    static final class GTToken extends Token {

        int realKind = ASTParserConstants.GT;
        int bufPos;
        GTToken(int kind, String image, int bufPos) {
            this.kind = kind;
            this.image = image;
            this.bufPos = bufPos;
        }

        public GTToken setBufPos(int bufPos) {
            this.bufPos = bufPos;
            return this;
        }

        public static Token newToken(int kind, String image, int bufPos) {
            return new GTToken(kind, image, bufPos);
        }
        public static Token newToken(int kind, String image) {
            return new GTToken(kind, image, -1);
        }
    }

    private Token last_special_token = null;

    private boolean putBackTokens() {
          Token root = new Token(), last=root;
          root.next = null;

          if (token.next != null) {
            // If there are any tokens generated by lookahead, let's slice them off...
            // Because we ignore whitespace, to do this correctly, we store the bufPos of each token
            // such that we can just rewind to
            int putBack = token_source.input_stream.bufpos - (((GTToken)token).bufPos + token.image.length());
            token_source.backup(putBack);
            token.next = null;
          }
          jj_ntk = -1;
          jj_lastpos = jj_scanpos;
          return true;
    }

    private boolean setState(int state) {
      if (state == token_source.curLexState) {
        return false;
      }
      putBackTokens();
      token_source.SwitchTo(state);
      return true;
    }
}

PARSER_END(ASTParser)

TOKEN_MGR_DECLS : {

  void CommonTokenAction(Token t) {
    ((com.github.javaparser.ASTParser.GTToken)t).bufPos = input_stream.bufpos - t.image.length();
  }

  int setState(int state) {
    int was = curLexState;
    curLexState = state;
    return was;
  }

  void backup(int n) { input_stream.backup(n); }

  char peekNext() {
    return peekNext(true);
  }

  char peekNext(boolean eatWhitespace) {
    int backup = 0;
    char c = 0;
    try {
      if (eatWhitespace) {
        backup += eatWhitespaceAndComments();
        c = input_stream.readChar();
        backup ++;
      } else {
        c = input_stream.readChar();
        backup ++;
      }
    } catch (IOException e) {
      // Hit EOF while peeking...
    } finally {
      input_stream.backup(backup);
    }
    return c;
  }

  int eatWhitespace() {
    int backup = 0;
    int amt = 0;
    char c = 0;
    try {
      c = input_stream.readChar();
      backup ++;
      while (Character.isWhitespace(c)) {
          backup = 1;
          amt ++;
          c = input_stream.readChar();
      }
    } catch (IOException e) {
      // Hit EOF while peeking...
      return amt;
    } finally {
        input_stream.backup(backup);
    }
    return amt;
  }
  int eatComments() {
    int backup = 0;
    int amt = 0;
    char c = 0;
    try {
      c = input_stream.readChar();
      backup ++;
      if (c == '/') {
          c = input_stream.readChar();
          if (c == '*') {
              backup = 0;
              amt = 2;
              do {
                  while ((c = input_stream.readChar()) != '*') {
                      amt ++;
                  }
                  amt ++;
              } while ((c = input_stream.readChar()) != '/');
              amt++;
          } else if (c == '/') {
              backup = 0;
              amt = 2;
              while ((c = input_stream.readChar()) != '\n') {
                  amt ++;
              }
              if (c == '\n') {
                amt++;
              }
          } else {
              backup++;
              return 0;
          }
      }
    } catch (IOException e) {
      // Hit EOF while peeking...
      return amt;
    } finally {
        input_stream.backup(backup);
    }
    return amt;
  }

  int eatWhitespaceAndComments() {
    int ws, comments, backup = 0;
    do {
      ws = eatWhitespace();
      comments = eatComments();
      backup += ws + comments;
    } while (ws > 0 || comments > 0);
    return backup;
  }

  boolean isAnnotation(Token token) {
    if (token.next != null) {
      return token.next.image.equals("@");
    }
    return peekNext() == '@';
  }

  boolean isCommaNotTrailing(Token token) {
    char c;
    if (token.next != null) {
      if (",".equals(token.next.image)) {
        if (token.next.next != null) {
          switch(token.next.next.image) {
            case "}":
            case "]":
              return true;
            default:
              return false;
          }
        }
        c = peekNext();
        return c != '}' && c != ']';
      }
      return false;
    }
    int backup = 0;
    try {
      backup += eatWhitespaceAndComments();
      c = input_stream.readChar();
      backup ++;
      if (c == ',') {
        backup += eatWhitespaceAndComments();
        c = input_stream.readChar();
        backup ++;
        return c != '}' && c != ']';
      }
    } catch (IOException e) {
    } finally {
        input_stream.backup(backup);
    }
    return false;
  }

  boolean isCommaCloseJson(Token token) {
    char c;
    if (token.next != null) {
      if (",".equals(token.next.image)) {
        if (token.next.next != null) {
          switch(token.next.next.image) {
            case "}":
            case "]":
              return true;
            default:
              return false;
          }
        }
        c = peekNext();
        return c == '}' || c == ']';
      }
      return false;
    }
    int backup = 0;
    try {
      backup += eatWhitespaceAndComments();
      c = input_stream.readChar();
      backup ++;
      if (c == ',') {
        backup += eatWhitespaceAndComments();
        c = input_stream.readChar();
        backup ++;
        return c == '}' || c == ']';
      }
    } catch (IOException e) {
    } finally {
        input_stream.backup(backup);
    }
    return false;
  }
  boolean isMemberBody(Token token) {
    if (token.next != null) {
      return token.next.image.matches("public|private|protected");
    }
    input_stream.backup(0);
    if (peekNext() == 'p') {
      int backup = 0;
      try {
        backup += eatWhitespaceAndComments();
        char c = input_stream.readChar();
        backup ++;
        assert c == 'p';
        c = input_stream.readChar();
        backup ++;
        switch (c) {
          case 'u'://blic
            c = input_stream.readChar();
            backup ++;
            if (c != 'b') {
              return false;
            }
            c = input_stream.readChar();
            backup ++;
            if (c != 'l') {
              return false;
            }
            c = input_stream.readChar();
            backup ++;
            if (c != 'i') {
              return false;
            }
            c = input_stream.readChar();
            backup ++;
            if (c != 'c') {
              return false;
            }
            c = input_stream.readChar();
            backup ++;
            return Character.isWhitespace(c);

          case 'r'://rivate | rotected
            c = input_stream.readChar();
            backup ++;
            switch (c) {
              case 'i'://ivate
                c = input_stream.readChar();
                backup ++;
                if (c != 'v') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 'a') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 't') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 'e') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                return Character.isWhitespace(c);

              case 'o'://otected
                c = input_stream.readChar();
                backup ++;
                if (c != 't') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 'e') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 'c') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 't') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 'e') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                if (c != 'd') {
                  return false;
                }
                c = input_stream.readChar();
                backup ++;
                return Character.isWhitespace(c);
            }
        }
      } catch (IOException e) {
      } finally {
        input_stream.backup(backup);
      }
    }
    return false;
  }

  boolean looksLikeNumber(Token token) {
    if (token.next != null) {
      token = token.next;
      if ("-".equals(token.image)) {
        if (token.next != null) {
          return Character.isDigit(token.next.image.charAt(0));
        }
        // only the - token is found, fall through to "check stream for numbers" below
      } else {
          return Character.isDigit(token.image.charAt(0));
      }
    }
    char c = peekNext();
    if (c == '-') {
      int backup = 0;
      try {
        backup = eatWhitespaceAndComments();
        c = input_stream.readChar();
        backup ++;
        assert c == '-';
        backup += eatWhitespaceAndComments();
        c = input_stream.readChar();
        return Character.isDigit(c);
      } catch (IOException e) {
      } finally {
        input_stream.backup(backup);
      }
    }
    return Character.isDigit(c);
  }
  boolean looksLikeInitializer(Token token) {
    boolean checkStatic = true;
    if (token.next != null) {
      if (token.next.image.equals("static")) {
        if (token.next.next != null) {
           return token.next.next.image.equals("{");
        }
        checkStatic = false;
      } else {
        return token.next.image.equals("{");
      }
    }
    input_stream.backup(0);
    int backup = 0;
    try {
      backup = eatWhitespaceAndComments();
      switch (peekNext()) {
          case '{':
            return true;
          case 's':
            if (!checkStatic) {
              return false;
            }
            char c = input_stream.readChar();
            backup++;
            assert c == 's';

            c = input_stream.readChar();
            backup++;
            if (c != 't') {
              return false;
            }

            c = input_stream.readChar();
            backup++;
            if (c != 'a') {
              return false;
            }

            c = input_stream.readChar();
            backup++;
            if (c != 't') {
              return false;
            }

            c = input_stream.readChar();
            backup++;
            if (c != 'i') {
              return false;
            }

            c = input_stream.readChar();
            backup++;
            if (c != 'c') {
              return false;
            }

            c = input_stream.readChar();
            backup++;
            return Character.isWhitespace(c) || c == '{';
          default:
            return false;
      }
    } catch (IOException e) {
    } finally {
      input_stream.backup(backup);
    }
    return false;
  }

  boolean looksLikeCssSelector(Token token) {
    int backup = 0;
    if (token.next != null) {
      // reverse the stream however far it is ahead,
      Token remove = token.next;
      while (remove != null) {
        backup -= remove.image.length();
        input_stream.backup(remove.image.length());
        remove = remove.next;
      }
    }
    // TODO make this far stricter,
    // and in doing so, be able to support more advanced selectors
    char c;
    try {
      boolean sawNonSpace = false;
      boolean previousWasAlphaNum = false;
      while (true) {
          c = input_stream.readChar();
          backup ++;
          switch (c) {
            case '{':
              return sawNonSpace;
            case '~':
            case '+':
            case '>':
              // Avoid matching e->{ (lambdas)
              if (!previousWasAlphaNum) {
                return false;
              }
            case '.':
            case '#':
            case '-':
            case '_':
            case ':':
              previousWasAlphaNum = false;
              sawNonSpace = true;
              break;
            default:
              if (Character.isLetterOrDigit(c)) {
                previousWasAlphaNum = true;
                sawNonSpace = true;
              } else if (!Character.isWhitespace(c)){
                return false;
              }
          }
      }
    } catch (IOException ignore) {
      // Hit EOF while peeking...
    } finally {
      input_stream.backup(backup);
    }
  return false;
  }

  boolean looksLikeJson(Token token) {
    if (token.next != null) {
      return token.next.image.equals("[") || token.next.image.equals("{");
    }
    char c = peekNext();
    return c == '[' || c == '{';
  }

  boolean looksLikeMethodOrLambda() {
    // look for a valid java name followed by ->, :: or (
    int backup = 1;
    input_stream.backup(0);
    try {
        char c = input_stream.readChar();

        while(Character.isWhitespace(c)) {
            backup++;
            c = input_stream.readChar();
        }
        if (c == '.') {
          while (c == '.' || Character.isJavaIdentifierPart(c)) {
            backup++;
            c = input_stream.readChar();
          }
          while(Character.isWhitespace(c)) {
              backup++;
              c = input_stream.readChar();
          }
        }
        switch (c) {
          case '-':
            backup++;
            c = input_stream.readChar();
            return c == '>';
          case ':':
            backup++;
            c = input_stream.readChar();
            return c == ':';
          case '(':
            return true;
          default:
            return false;
        }
    } catch (IOException e){
        return false;
    } finally {
      input_stream.backup(backup);
    }
  }
}

/* WHITE SPACE */
< DEFAULT, CSS_BODY, UI_BODY, JSON_BODY >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */
< DEFAULT, CSS_BODY, UI_BODY, JSON_BODY >
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

< DEFAULT, CSS_BODY, UI_BODY, JSON_BODY >
MORE :
{
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_JAVA_DOC_COMMENT
|
  <"/*"> : IN_MULTI_LINE_COMMENT
}

<IN_JAVA_DOC_COMMENT>
SPECIAL_TOKEN :
{
  <JAVA_DOC_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<UI_COMMENT_MODE>
TOKEN :
{
  <UI_COMMENT_BODY: ( ~["-"] | " " | ( "-" ~["-"] ) | ( "--" ~[">"] ) ) +  >
| <END_UI_COMMENT: "-->" >
}

<IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


<UI_BODY>
TOKEN:
{
   < END_UI_BODY: "</" > { input_stream.backup(2); } : DEFAULT
 | < UI_COMMENT: "<!--" > : UI_COMMENT_MODE
 | < UI_TEXT: (
    ~["<"]
 )+ >
}

<CSS_BODY>
TOKEN:
{
    <HEX_COLOR: "#" ( ( ["0"-"9"] | ["a"-"f"] | ["A"-"F"] ) {3} | ( ["0"-"9"] | ["a"-"f"] | ["A"-"F"] ) {6}  ) >
  | < CSS_KEY: ["-"] ( ["-"] )? (
     (
        ( ["a"-"z"] | ["A"-"Z"] | "_" ) ( "-" ["0"-"9"] | ["a"-"z"] | ["A"-"Z"] | "_" ) *
     )+
     ) >
  | < CSS_SELECTOR: (

        ( ( "." | "#" | ":" | "::" ) ( ["0"-"9"] | ["a"-"z"] | ["A"-"Z"] | "::" | "-" | "_" )+ )
        |
        ( ( ["a"-"z"] | ["A"-"Z"] )+ ("-" | "::" ) ( ["0"-"9"] | ["a"-"z"] | ["A"-"Z"] ( "-" | "::" ) )* )
     )
     (
       ( ">" | "~" | "+" | ":" | "::" ) ?
         ( ["." , "#"] )? ( ["0"-"9"] | ["a"-"z"] | ["A"-"Z"] | "::" | "-" | "_" )+
     )*
 >
 | < CSS_SELECTOR_JOIN: ( ">" | "~" | "+" )>
 | < START_CSS_BLOCK : ".{" >
 | < START_CSS_INLINE : ":{" >
 | <IMPORTANT: "!important" >
 | <CSS_UNIT: ( "px" | "em" | "ems" | "pc" | "cm" | "mm" | "in" | "pt" | "ex" | "rem" |
  "rad" | "grad" | "deg" | "eg" // matches deg when 180d is matches as a double literal...
   | "s" | "ms" | "hz" | "khz" | "dpi" | "pi" | "dpcm" | "pcm" | "%" ) >

}

/* RESERVED WORDS AND LITERALS */
< DEFAULT, CSS_BODY, UI_BODY, JSON_BODY >
TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < DOCTYPE: "<!" [ "d", "D" ] [ "o", "O" ] [ "c", "C" ] [ "t", "T" ] [ "y", "Y" ] [ "p", "P" ] [ "e", "E" ] " " >

|  < BEGIN_EXPR: "$." >
|  < BEGIN_DECL: "$:" >
// xapi language escape sequences
|  < START_JAVA: "`java:" >
| < END_JAVA: ":java`" >
| < START_HTML: "`html:" >
| < END_HTML: ":html`" >
| < START_CSS: "`css:" >
| < END_CSS: ":css`" >
| < START_PI: "`@" >
| < END_PI: "@`" >
| < START_UI: "`<" > { input_stream.backup(1); } : UI_BODY
| < START_SCRIPT: "`{" >
| < END_SCRIPT: "}`" >
}

/* LITERALS */

< DEFAULT, CSS_BODY, UI_BODY, JSON_BODY >
TOKEN :
{
  < LONG_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])
      | <HEX_LITERAL> (["l","L"])
      | <OCTAL_LITERAL> (["l","L"])
      | <BINARY_LITERAL> (["l","L"])
  >
|
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      | <BINARY_LITERAL>
  >
|
  < #DECIMAL_LITERAL: (["0"-"9"]((["0"-"9","_"])*["0"-"9"])?) >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"]((["0"-"9","a"-"f","A"-"F","_"])*["0"-"9","a"-"f","A"-"F"])?) >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"]((["0"-"7","_"])*["0"-"7"])?) >
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0","1"]((["0","1","_"])*["0","1"])?) >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (<DECIMAL_LITERAL>)+ "." (<DECIMAL_LITERAL>)* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (<DECIMAL_LITERAL>)+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (<DECIMAL_LITERAL>)+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (<DECIMAL_LITERAL>)+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (<DECIMAL_LITERAL>)+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\\u"
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\\u"
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
          )
      )*
      "\""
  >
|
  < TEMPLATE_LITERAL:
      "`"
      (
        ~["`"] |
        ( "\\`" )
      )*
      "`"
  >
/* IDENTIFIERS */
| < IDENTIFIER: (<LETTER> (<PART_LETTER>)*) >
| < FEATURE_IDENTIFIER: (<LETTER> ( ( <IDENTIFIER> | "-" | "*" ) + ( <IDENTIFIER> | "*" ) )? ) >
| < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "\u0024",          // "$"
         "\u0041"-"\u005a", // "A"-"Z"
         "\u005f",          // "_"
         "\u0061"-"\u007a", // "a"-"z"
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u0236",
         "\u0250"-"\u02c1",
         "\u02c6"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03f5",
         "\u03f7"-"\u03fb",
         "\u0400"-"\u0481",
         "\u048a"-"\u04ce",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0500"-"\u050f",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u064a",
         "\u066e"-"\u066f",
         "\u0671"-"\u06d3",
         "\u06d5",
         "\u06e5"-"\u06e6",
         "\u06ee"-"\u06ef",
         "\u06fa"-"\u06fc",
         "\u06ff",
         "\u0710",
         "\u0712"-"\u072f",
         "\u074d"-"\u074f",
         "\u0780"-"\u07a5",
         "\u07b1",
         "\u0904"-"\u0939",
         "\u093d",
         "\u0950",
         "\u0958"-"\u0961",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bd",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e1",
         "\u09f0"-"\u09f3",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a72"-"\u0a74",
         "\u0a85"-"\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abd",
         "\u0ad0",
         "\u0ae0"-"\u0ae1",
         "\u0af1",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b35"-"\u0b39",
         "\u0b3d",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b71",
         "\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bf9",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c60"-"\u0c61",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbd",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d60"-"\u0d61",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0e01"-"\u0e30",
         "\u0e32"-"\u0e33",
         "\u0e3f"-"\u0e46",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb0",
         "\u0eb2"-"\u0eb3",
         "\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f40"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f88"-"\u0f8b",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u1050"-"\u1055",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f8",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u16ee"-"\u16f0",
         "\u1700"-"\u170c",
         "\u170e"-"\u1711",
         "\u1720"-"\u1731",
         "\u1740"-"\u1751",
         "\u1760"-"\u176c",
         "\u176e"-"\u1770",
         "\u1780"-"\u17b3",
         "\u17d7",
         "\u17db"-"\u17dc",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a8",
         "\u1900"-"\u191c",
         "\u1950"-"\u196d",
         "\u1970"-"\u1974",
         "\u1d00"-"\u1d6b",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u203f"-"\u2040",
         "\u2054",
         "\u2071",
         "\u207f",
         "\u20a0"-"\u20b1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u213d"-"\u213f",
         "\u2145"-"\u2149",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u3029",
         "\u3031"-"\u3035",
         "\u3038"-"\u303c",
         "\u3041"-"\u3096",
         "\u309d"-"\u309f",
         "\u30a1"-"\u30ff",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u31f0"-"\u31ff",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\ud801", //for supplementary characters suport
         "\ud802", //for supplementary characters suport
         "\uf900"-"\ufa2d",
         "\ufa30"-"\ufa6a",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d",
         "\ufb1f"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfc",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe74",
         "\ufe76"-"\ufefc",
         "\uff04",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "\u0024",          // "$"
         "\u0030"-"\u0039", // "0"-"9"
         "\u0041"-"\u005a", // "A"-"Z"
         "\u005f",          // "_"
         "\u0061"-"\u007a", // "a"-"z"
         "\u007f"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00ad",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u0236",
         "\u0250"-"\u02c1",
         "\u02c6"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u0357",
         "\u035d"-"\u036f",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03f5",
         "\u03f7"-"\u03fb",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048a"-"\u04ce",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0500"-"\u050f",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0600"-"\u0603",
         "\u0610"-"\u0615",
         "\u0621"-"\u063a",
         "\u0640"-"\u0658",
         "\u0660"-"\u0669",
         "\u066e"-"\u06d3",
         "\u06d5"-"\u06dd",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06fc",
         "\u06ff",
         "\u070f"-"\u074a",
         "\u074d"-"\u074f",
         "\u0780"-"\u07b1",
         "\u0901"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a01"-"\u0a03",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0"-"\u0ae3",
         "\u0ae6"-"\u0aef",
         "\u0af1",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b35"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b71",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0bf9",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbc"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f8",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u16ee"-"\u16f0",
         "\u1700"-"\u170c",
         "\u170e"-"\u1714",
         "\u1720"-"\u1734",
         "\u1740"-"\u1753",
         "\u1760"-"\u176c",
         "\u176e"-"\u1770",
         "\u1772"-"\u1773",
         "\u1780"-"\u17d3",
         "\u17d7",
         "\u17db"-"\u17dd",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180d",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1900"-"\u191c",
         "\u1920"-"\u192b",
         "\u1930"-"\u193b",
         "\u1946"-"\u196d",
         "\u1970"-"\u1974",
         "\u1d00"-"\u1d6b",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u2054",
         "\u2060"-"\u2063",
         "\u206a"-"\u206f",
         "\u2071",
         "\u207f",
         "\u20a0"-"\u20b1",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u20e5"-"\u20ea",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u213d"-"\u213f",
         "\u2145"-"\u2149",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303c",
         "\u3041"-"\u3096",
         "\u3099"-"\u309a",
         "\u309d"-"\u309f",
         "\u30a1"-"\u30ff",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u31f0"-"\u31ff",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\ud801", //for supplementary characters suport
         "\ud802", //for supplementary characters suport
         "\ud834", //for supplementary characters suport
         "\udc00", //for supplementary characters suport
         "\udc01", //for supplementary characters suport
         "\udd7b", //for supplementary characters suport
         "\uf900"-"\ufa2d",
         "\ufa30"-"\ufa6a",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfc",
         "\ufe00"-"\ufe0f",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"
      ]
  >


/* SEPARATORS */
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >


/* OPERATORS */
| < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < ARROW: "->" >
| < DOUBLECOLON: "::" >
}

/* >'s need special attention due to generics syntax. */
< DEFAULT, CSS_BODY, UI_BODY, JSON_BODY >
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((ASTParser.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((ASTParser.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
  }
| < GT: ">" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

CompilationUnit CompilationUnit():
{
	PackageDeclaration pakage = null;
	List imports = null;
	ImportDeclaration in = null;
	List types = null;
	TypeDeclaration tn = null;
	int line = -1;
	int column = 0;
}
{
  [ LOOKAHEAD(PackageDeclaration()) pakage = PackageDeclaration() {line = pakage.getBeginLine(); column = pakage.getBeginColumn();} ]
  ( in = ImportDeclaration()      { if(line==-1){line = in.getBeginLine(); column = in.getBeginColumn();} imports = add(imports, in); } |
    in = EmptyImportDeclaration() { if(line==-1){line = in.getBeginLine(); column = in.getBeginColumn();} imports = add(imports, in); } )*
  ( tn = TypeDeclaration() { if(line==-1){line = tn.getBeginLine(); column = tn.getBeginColumn();} types = add(types, tn); } )*
  (<EOF> | "\u001A" /** ctrl+z char **/)
  { return new CompilationUnit(line == -1 ? 0 : line, column, token.endLine, token.endColumn,pakage, imports, types); }
}

ImportDeclaration EmptyImportDeclaration():
{
	int line = -1;
	int column = 0;
}
{
    ";"
    { return ImportDeclaration.createEmptyDeclaration(line, column, token.endLine, token.endColumn); }
}

PackageDeclaration PackageDeclaration():
{
	List annotations = null;
	AnnotationExpr ann;
	NameExpr name;
	int line;
	int column;
}
{
( ann = Annotation() { annotations = add(annotations, ann); } )*
  "package" {line=token.beginLine; column=token.beginColumn;}  name = Name() ";"
  { return new PackageDeclaration(line, column, token.endLine, token.endColumn,annotations, name); }
}

ImportDeclaration ImportDeclaration():
{
	NameExpr name;
	boolean isStatic = false;
	boolean isAsterisk = false;
	int line;
	int column;
}
{
  "import" {line=token.beginLine; column=token.beginColumn;} [ "static" { isStatic = true; } ] name = Name() [ "." "*" { isAsterisk = true; } ] ";"
  { return new ImportDeclaration(line, column, token.endLine, token.endColumn,name, isStatic, isAsterisk); }
}

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */

Modifier Modifiers():
{
    int beginLine = -1;
    int beginColumn = -1;
    int modifiers = 0;
    List annotations = null;
    AnnotationExpr ann;
}
{
 (
  LOOKAHEAD(2)
  (
   "public" { modifiers = addModifier(modifiers, ModifierSet.PUBLIC, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "static" { modifiers = addModifier(modifiers, ModifierSet.STATIC, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "protected" { modifiers = addModifier(modifiers, ModifierSet.PROTECTED, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "private" { modifiers = addModifier(modifiers, ModifierSet.PRIVATE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "final" { modifiers = addModifier(modifiers, ModifierSet.FINAL, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "abstract" { modifiers = addModifier(modifiers, ModifierSet.ABSTRACT, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "synchronized" { modifiers = addModifier(modifiers, ModifierSet.SYNCHRONIZED, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "native" { modifiers = addModifier(modifiers, ModifierSet.NATIVE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "transient" { modifiers = addModifier(modifiers, ModifierSet.TRANSIENT, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "volatile" { modifiers = addModifier(modifiers, ModifierSet.VOLATILE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   "strictfp" { modifiers = addModifier(modifiers, ModifierSet.STRICTFP, token);  if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
  |
   ann = Annotation() { annotations = add(annotations, ann); if(beginLine==-1) {beginLine=ann.getBeginLine(); beginColumn=ann.getBeginColumn();} }
  )
 )*

 {
    return new Modifier(beginLine, beginColumn, modifiers, annotations);
 }
}

/*
 * Declaration syntax follows.
 */
TypeDeclaration TypeDeclaration():
{
   Modifier modifier;
   TypeDeclaration ret;
}
{
  {  }
  (
    ";" { ret = new EmptyTypeDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
  |
    modifier = Modifiers()
    (
       ret = ClassOrInterfaceDeclaration(modifier)
     |
       ret = EnumDeclaration(modifier)
     |
       ret = AnnotationTypeDeclaration(modifier)
    )
  )
  { return ret; }
}


ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration(Modifier modifier):
{
   boolean isInterface = false;
   NameExpr name;
   List typePar = null;
   List extList = null;
   List impList = null;
   List members;
   int line = modifier.beginLine;
   int column = modifier.beginColumn;
}
{
  ( "class" | "interface" { isInterface = true; } ) { if (line == -1) {line=token.beginLine; column=token.beginColumn;} }
  name = Name()
  [ typePar = TypeParameters() {typePar.remove(0);} ]
  [ extList = ExtendsList(isInterface) ]
  [ impList = ImplementsList(isInterface) ]
  members = ClassOrInterfaceBody(isInterface)

  { ClassOrInterfaceDeclaration tmp = new ClassOrInterfaceDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, isInterface, null, typePar, extList, impList, members);
    tmp.setNameExpr(name);
    return tmp;
  }
}

List ExtendsList(boolean isInterface):
{
   boolean extendsMoreThanOne = false;
   List ret = new LinkedList();
   ClassOrInterfaceType cit;
    AnnotationExpr ann;
   List annotations = null;
}
{
   "extends" (ann = Annotation()   { annotations = add(annotations, ann);})* cit = ClassOrInterfaceType() { cit.setAnnotations(annotations); ret.add(cit); }
   ( "," cit = ClassOrInterfaceType() { ret.add(cit); extendsMoreThanOne = true; } )*
   {
      if (extendsMoreThanOne && !isInterface)
         throwParseException(token, "A class cannot extend more than one other class");
   }
   { return ret; }
}

List ImplementsList(boolean isInterface):
{
   List ret = new LinkedList();
   ClassOrInterfaceType cit;
}
{
   "implements" cit = ClassOrInterfaceTypeWithAnnotations() { ret.add(cit); }
   ( "," cit = ClassOrInterfaceTypeWithAnnotations() { ret.add(cit); } )*
   {
      if (isInterface)
         throwParseException(token, "An interface cannot implement other interfaces");
   }
   { return ret; }
}

EnumDeclaration EnumDeclaration(Modifier modifier):
{
	NameExpr name;
	List impList = null;
	EnumConstantDeclaration entry;
	List entries = null;
	BodyDeclaration member;
	List members = null;
	int line = modifier.beginLine;
	int column = modifier.beginColumn;
}
{
  "enum" { if (line == -1) {line=token.beginLine; column=token.beginColumn;} }
  name = Name()
  [ impList = ImplementsList(false) ]
  "{"
  	[
    	{ entries = new LinkedList(); }
    	entry = EnumConstantDeclaration() { entries.add(entry); } ( LOOKAHEAD(2) "," entry = EnumConstantDeclaration() { entries.add(entry); } )*
  	]
  	[ "," ]
 	[
 	 	( ";" ( member = ClassOrInterfaceBodyDeclaration(false) { members = add(members, member); } )* )
 	]
  "}"

  {
      EnumDeclaration tmp = new EnumDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, null, impList, entries, members);
      tmp.setNameExpr(name);
      return tmp;
  }
}


EnumConstantDeclaration EnumConstantDeclaration():
{
	List annotations = null;
	AnnotationExpr ann;
	String name;
	List args = null;
	List classBody = null;
	int line = -1;
	int column = -1;

}
{
  {  }
  ( ann = Annotation() { annotations = add(annotations, ann); if(line==-1){line=ann.getBeginLine(); column=ann.getBeginColumn();} } )*
  <IDENTIFIER> { name = token.image; if(line==-1){line=token.beginLine; column=token.beginColumn;} }
  [ args = Arguments() ] [ classBody = ClassOrInterfaceBody(false) ]
  {
      EnumConstantDeclaration tmp = new EnumConstantDeclaration(line, column, token.endLine, token.endColumn, annotations, name, args, classBody);

      return tmp;
  }
}

List TypeParameters():
{
	List ret = new LinkedList();
	TypeParameter tp;
	List annotations = null;
	AnnotationExpr ann;
}
{
   "<" { ret.add(new int[]{token.beginLine, token.beginColumn}); }
   (ann = Annotation()   { annotations = add(annotations, ann);})*

   tp = TypeParameter() { ret.add(tp); tp.setAnnotations(annotations); annotations = null; }
   ( "," (ann = Annotation()   { annotations = add(annotations, ann);})* tp = TypeParameter() { ret.add(tp); tp.setAnnotations(annotations); annotations = null; } )*
   ">"
   { return ret; }
}

TypeParameter TypeParameter():
{
	String name;
	List typeBound = null;
	int line;
	int column;
}
{
   <IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn;} [ typeBound = TypeBound() ]
   { return new TypeParameter(line, column, token.endLine, token.endColumn,name, typeBound); }
}

List TypeBound():
{
	List ret = new LinkedList();
	ClassOrInterfaceType cit;
	AnnotationExpr ann;
	List annotations = null;
}
{
   "extends" (ann = Annotation()   { annotations = add(annotations, ann);})* cit = ClassOrInterfaceType() { cit.setAnnotations(annotations); ret.add(cit); annotations=null;}
   ( "&"   (ann = Annotation()   { annotations = add(annotations, ann);})*  cit = ClassOrInterfaceType() { cit.setAnnotations(annotations); ret.add(cit); annotations=null;} )*
   { return ret; }
}

List ClassOrInterfaceBody(boolean isInterface):
{
	List ret = new LinkedList();
	BodyDeclaration member;
}
{
  "{" ( member = ClassOrInterfaceBodyDeclaration(isInterface) { ret.add(member); }  )* "}"
  { return ret; }
}

BodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface):
{
   boolean isNestedInterface = false;
   Modifier modifier;
   Modifier modifier2 = null;
   int aux = 0;
   BodyDeclaration ret;
   boolean isDefault = false;
}
{
  {  }
  (
	  LOOKAHEAD( { token_source.looksLikeInitializer(token) } )
	  ret = InitializerDeclaration()
	  {
	     if (isInterface)
	        throwParseException(token, "An interface cannot have initializers");
	  }
	|
	  modifier = Modifiers() [ "default" modifier2= Modifiers()
	  {
	    if(!isInterface)
	    {
	      throwParseException(token, "A non-interface cannot have default members");
	    }
	    isDefault = true;
	  }]

				// Just get all the modifiers out of the way. If you want to do
	              // more checks, pass the modifiers down to the member
	  (
	      ret = ClassOrInterfaceDeclaration(modifier)
	    |
	      ret = EnumDeclaration(modifier)
	    |
	      ret = AnnotationTypeDeclaration(modifier)
	    |
	      LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> "(" )
	      ret = ConstructorDeclaration(modifier)
	    |
	      LOOKAHEAD( Type() <IDENTIFIER> ( "[" "]" )* ( "," | "=" | ";" ) )
	      ret = FieldDeclaration(modifier)
	    |
	      ret = MethodDeclaration(modifier)
	      {
	        if(isDefault && ret!= null && ((MethodDeclaration)ret).getBody() == null)
	        {
	          throwParseException(token, "'default' methods must have a body");
	        }
	        ((MethodDeclaration)ret).setDefault(isDefault);
	        if(modifier2!= null)
	        {
	          aux = modifier2.modifiers;
	        }
	        ((MethodDeclaration)ret).setModifiers(addModifier(modifier.modifiers, aux, token));
	      }
	  )
	  {
	    if(isDefault && ! (ret instanceof MethodDeclaration))
	    {
	      throwParseException(token, "Just methods can have the keyword 'default'.");
	    }
	  }
	|
	  ";" { ret = new EmptyMemberDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
  )
  { return ret; }
}

FieldDeclaration FieldDeclaration(Modifier modifier):
{
	Type type;
	List variables = new LinkedList();
	VariableDeclarator val;
}
{
  // Modifiers are already matched in the caller
  type = Type()
        val = VariableDeclarator() { variables.add(val); }
  ( "," val = VariableDeclarator() { variables.add(val); } )* ";"

  {
  	int line = modifier.beginLine;
  	int column = modifier.beginColumn;
  	if (line == -1) { line=type.getBeginLine(); column=type.getBeginColumn(); }
  	return new FieldDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, variables);
  }
}

VariableDeclarator VariableDeclarator():
{
	VariableDeclaratorId id;
	Expression init = null;
}
{
  id = VariableDeclaratorId() [ "=" init = VariableInitializer() ]
  { return new  VariableDeclarator(id.getBeginLine(), id.getBeginColumn(), token.endLine, token.endColumn, id, init); }
}

VariableDeclaratorId VariableDeclaratorId():
{
	String name;
	int arrayCount = 0;
	int line;
	int column;
}
{
  <IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn;}  ( "[" "]" { arrayCount++; } )*
  { return new VariableDeclaratorId(line, column, token.endLine, token.endColumn,name, arrayCount); }
}

Expression VariableInitializer():
{
	Expression ret;
}
{
  (
	  ret = ArrayInitializer()
	|
	  ret = Expression()
  )
  { return ret;}
}

ArrayInitializerExpr ArrayInitializer():
{
	List values = null;
	Expression val;
	int line;
	int column;
}
{
  "{" {line=token.beginLine; column=token.beginColumn;} [ val = VariableInitializer() { values = add(values, val); } ( LOOKAHEAD(2) "," val = VariableInitializer() { values = add(values, val); } )* ] [ "," ] "}"
  { return new ArrayInitializerExpr(line, column, token.endLine, token.endColumn,values); }
}

MethodDeclaration MethodDeclaration(Modifier modifier):
{
	List typeParameters = null;
	Type type;
	NameExpr name;
	List parameters;
	int arrayCount = 0;
	List throws_ = null;
	BlockStmt block = null;
	int line = modifier.beginLine;
	int column = modifier.beginColumn;
	Type throwType;
}
{
  // Modifiers already matched in the caller!
  [ typeParameters = TypeParameters() { int[] lineCol=(int[])typeParameters.remove(0); if(line==-1){ line=lineCol[0]; column=lineCol[1];} } ]
  type = ResultType() { if(line==-1){line=type.getBeginLine(); column=type.getBeginColumn();}}
  name = Name() parameters = FormalParameters() ( "[" "]" { arrayCount++; } )*
  [ "throws" throwType = ReferenceTypeWithAnnotations() { throws_ = add(throws_, throwType); }
    ("," throwType = ReferenceTypeWithAnnotations() { throws_ = add(throws_, throwType); })* ]
  ( block = Block() | ";" )
  {
      MethodDeclaration tmp = new MethodDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, typeParameters, type, null, parameters, arrayCount, throws_, block);
      tmp.setNameExpr(name);
      return tmp;
  }
}

ReferenceType ReferenceTypeWithAnnotations():
{
	List annotations = new ArrayList();
	AnnotationExpr annotation = null;
	ReferenceType type;
}
{
    (annotation = Annotation() { annotations = add(annotations, annotation); } )* type = ReferenceType() {
        if (type.getAnnotations() != null) {
            type.getAnnotations().addAll(annotations);
        } else {
            type.setAnnotations(annotations);
        }
        return type;
    }
}

List FormalParameters():
{
	List ret = null;
	Parameter par;
}
{
  "(" [ par = FormalParameter() { ret = add(ret, par); } ( "," par = FormalParameter() { ret = add(ret, par); } )* ] ")"

  { return ret; }
}

List FormalLambdaParameters():
{
  List ret = null;
  Parameter par;
}
{
   ","
  	par = FormalParameter() {  ret = add(ret, par);  } ( "," par = FormalParameter() { ret = add(ret, par); } )*
  { return ret;  }
}

List InferredLambdaParameters():
{
  List ret = null;
  VariableDeclaratorId id;
}
{
   ","
  	id = VariableDeclaratorId() 	{ ret = add(ret, new Parameter(id.getBeginLine(), id.getBeginColumn(), id.getEndLine(), id.getEndColumn(), 0, null, new UnknownType(), false, id));}
  (
    "," id = VariableDeclaratorId()  { ret = add(ret, new Parameter(id.getBeginLine(), id.getBeginColumn(), id.getEndLine(), id.getEndColumn(), 0, null, new UnknownType(), false, id)); }
  )*
  { return ret;  }
}

Parameter FormalParameter():
{
	Modifier modifier;
	Type type;
	boolean isVarArg = false;
	VariableDeclaratorId id;
}
{
  modifier = Modifiers() type = Type() [ "..." { isVarArg = true;} ] id = VariableDeclaratorId()

  {
    int line = modifier.beginLine;
    int column = modifier.beginColumn;
    if(line==-1){ line=type.getBeginLine(); column=type.getBeginColumn(); }
    return new Parameter(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, isVarArg, id);
  }
}

ConstructorDeclaration ConstructorDeclaration(Modifier modifier):
{
	List typeParameters = null;
	NameExpr name;
	List parameters;
	List throws_ = null;
	ExplicitConstructorInvocationStmt exConsInv = null;
	List stmts;
	int line = modifier.beginLine;
	int column = modifier.beginColumn;
	int bbLine = 0;
	int bbColumn = 0;
	int beLine = 0;
	int beColumn = 0;
}
{
  [ typeParameters = TypeParameters() { int[] lineCol=(int[])typeParameters.remove(0); if(line==-1){ line=lineCol[0]; column=lineCol[1];} } ]
  // Modifiers matched in the caller
  name = SimpleName() { if(line==-1){line=token.beginLine; column=token.beginColumn;}} parameters = FormalParameters() [ "throws" throws_ = NameList() ]
  "{" { bbLine=token.beginLine; bbColumn=token.beginColumn; }
    [ LOOKAHEAD(ExplicitConstructorInvocation()) exConsInv = ExplicitConstructorInvocation() ]
    stmts = Statements()
  "}"

  {
  	if (exConsInv != null) {
  		stmts = add(0, stmts, exConsInv);
  	}
  	ConstructorDeclaration tmp = new ConstructorDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, typeParameters, null, parameters, throws_, new BlockStmt(bbLine, bbColumn, token.endLine, token.endColumn, stmts));
    tmp.setNameExpr(name);
    return tmp;
  }
}

ExplicitConstructorInvocationStmt ExplicitConstructorInvocation():
{
	boolean isThis = false;
	List args;
	Expression expr = null;
	List typeArgs = null;
	int line = -1;
	int column = 0;
}
{
  (
	  LOOKAHEAD([ TypeArguments() ] <THIS> "(")
	  [ typeArgs = TypeArguments() { int[] lineCol=(int[])typeArgs.remove(0); line=lineCol[0]; column=lineCol[1]; } ]
	  <THIS> { if (line == -1) {line=token.beginLine; column=token.beginColumn;} isThis = true; }
	  args = Arguments() ";"
	|
	  [
	    LOOKAHEAD( PrimaryExpressionWithoutSuperSuffix() "." )
	  	expr = PrimaryExpressionWithoutSuperSuffix() "."
	  	{ line=expr.getBeginLine(); column=expr.getBeginColumn(); }
	  ]
	  [ typeArgs = TypeArguments() {int[] lineCol=(int[])typeArgs.remove(0); if (line == -1) {line=lineCol[0]; column=lineCol[1];}} ]
	  <SUPER> {if (line == -1) {line=token.beginLine; column=token.beginColumn;}}
	  args = Arguments() ";"
  )
  { return new ExplicitConstructorInvocationStmt(line, column, token.endLine, token.endColumn,typeArgs, isThis, expr, args); }
}

List Statements():
{
	List ret = null;
	Statement stmt;
}
{
	( stmt = BlockStatement() { ret = add(ret, stmt); } )*
	{ return ret; }
}

InitializerDeclaration InitializerDeclaration():
{
	BlockStmt block;
	int line = -1;
	int column = 0;
	boolean isStatic = false;
}
{
  [ "static" { isStatic = true; line=token.beginLine; column=token.beginColumn;} ] block = Block() {if(line==-1){line=block.getBeginLine(); column=block.getBeginColumn();}}
  { return new InitializerDeclaration(line, column, token.endLine, token.endColumn, isStatic, block); }
}


/*
 * Type, name and expression syntax follows.
 */

Type Type():
{
	Type ret;
}
{
 (
   LOOKAHEAD(2) ret = ReferenceType()
 |
   ret = PrimitiveType()
 )
 { return ret; }
}

ReferenceType ReferenceType():
{
	Type type;
	int arrayCount = 0;
	List annotations = null;
	List accum= null;
	AnnotationExpr ann;
}
{
  (
   type = PrimitiveType() ( LOOKAHEAD(2)  (ann = Annotation()   { annotations = add(annotations, ann);  })* "[" "]" { arrayCount++; accum = add(accum, annotations); annotations= null;} )+
  |
   type = ClassOrInterfaceType()  ( LOOKAHEAD(2) (ann = Annotation()   { annotations = add(annotations, ann);  })* "[" "]" { arrayCount++; accum = add(accum, annotations); annotations= null;} )*
  )
  { return new ReferenceType(type.getBeginLine(), type.getBeginColumn(), token.endLine, token.endColumn, type, arrayCount, null, accum); }
}

IntersectionType IntersectionType():
{
	int line;
	int column;
	Type elementType;
	List elements = null;
}
{
    elementType=ReferenceType() {
        line=elementType.getBeginLine(); column=elementType.getBeginColumn();
        elements = add(elements, elementType); }
    "&" (elementType=ReferenceType() { elements = add(elements, elementType); } )+
    { return new IntersectionType(line, column, token.endLine, token.endColumn, elements); }
}

ClassOrInterfaceType ClassOrInterfaceType():
{
	ClassOrInterfaceType ret;
	String name;
	List typeArgs = null;
	int line;
	int column;
	List annotations = null;
	AnnotationExpr ann;
}
{
  <IDENTIFIER> {line=token.beginLine; column=token.beginColumn;} { name = token.image; }
  [ LOOKAHEAD(2) typeArgs = TypeArguments() {typeArgs.remove(0);} ]
  {
      ret = new ClassOrInterfaceType(line, column, token.endLine, token.endColumn,null, name, createTypeArguments(typeArgs));
  }
  (
	  LOOKAHEAD(2) "." (ann = Annotation()   { annotations = add(annotations, ann);})*  <IDENTIFIER> { name = token.image; }
	  [ LOOKAHEAD(2) typeArgs = TypeArguments() {typeArgs.remove(0);} ]
	  {
	    ret = new ClassOrInterfaceType(line, column, token.endLine, token.endColumn,ret, name, createTypeArguments(typeArgs));
	    ret.setAnnotations(annotations);
	    annotations = null;
      }
  )*
  { return ret; }
}

ClassOrInterfaceType ClassOrInterfaceTypeWithAnnotations():
{
	List annotations = new ArrayList();
	AnnotationExpr annotation = null;
	ClassOrInterfaceType type;
}
{
    (annotation = Annotation() { annotations = add(annotations, annotation); } )* type = ClassOrInterfaceType() {
        if (type.getAnnotations() != null) {
            type.getAnnotations().addAll(annotations);
        } else {
            type.setAnnotations(annotations);
        }
        return type;
    }
}


List TypeArguments():
{
	List ret = new LinkedList();
	Type type;
}
{
   (
     "<" { ret.add(new int[]{token.beginLine, token.beginColumn}); }
     (type = TypeArgument() { ret.add(type); } ( "," type = TypeArgument() { ret.add(type); } )*)?
     ">"
   )
   { return ret; }
}

Type TypeArgument():
{
	Type ret;
	List annotations = null;
	AnnotationExpr ann;
}
{
  (ann = Annotation()   { annotations = add(annotations, ann);})*
 (
   ret = ReferenceType()
 |
   ret = Wildcard()
 )
 { ret.setAnnotations(annotations); return ret; }
}

WildcardType Wildcard():
{
	ReferenceType ext = null;
	ReferenceType sup = null;
	int line;
	int column;
	AnnotationExpr ann;
	List annotations = null;
}
{
   "?" {line=token.beginLine; column=token.beginColumn;}
   [
		"extends" (ann = Annotation()   { annotations = add(annotations, ann);})* ext = ReferenceType()
		{
		  ext.setAnnotations(annotations);
		}
	|
		"super" (ann = Annotation()   { annotations = add(annotations, ann);})* sup = ReferenceType()
		{
		  sup.setAnnotations(annotations);
		}
   ]
   {
     return new WildcardType(line, column, token.endLine, token.endColumn,ext, sup);
   }
}

PrimitiveType PrimitiveType():
{
	PrimitiveType ret;
}
{
(
  "boolean" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Boolean); }
|
  "char" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Char); }
|
  "byte" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Byte); }
|
  "short" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Short); }
|
  "int" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Int); }
|
  "long" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Long); }
|
  "float" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Float); }
|
  "double" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Double); }
)
{ return ret; }
}

Type ResultType():
{
	Type ret;
}
{
  (
	  "void" { ret = new VoidType(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
	|
	  ret = Type()
  )
  { return ret; }
}

NameExpr Name():
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
	NameExpr ret;
}
{
  <IDENTIFIER> { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image); }
  ( LOOKAHEAD(2) "." <IDENTIFIER> { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); } )*
  { return ret; }
}

NameExpr TagName():
{ NameExpr name; }
{
    name = FeatureName()
    { return name; }
}

NameExpr FeatureName():
/*
 * We want to allow all valid java and html attribute names,
 * so we additionally allow - to be in names.  * is allowed, but wildcard matching is not yet implemented
 */
{
	NameExpr ret;
}
{
  (
      <IDENTIFIER>
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | <FEATURE_IDENTIFIER>
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | <CSS_SELECTOR>
      {
        // TODO validate that this is a simple css selector, like tag-name
        // and not an illegal feature identifier, such as tag-name > other-tag
        ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
      }
      | "class"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "interface"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "enum"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "this"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "super"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "import"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "extends"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "package"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "default"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "implements"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "if"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "else"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "for"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "while"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "do"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "break"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "continue"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "switch"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "case"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
      | "return"
      { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);}
  )

  ( LOOKAHEAD(2) "."
   (
   <IDENTIFIER>
   { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); }
      | <FEATURE_IDENTIFIER>
   { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); }
      | "class"
   { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); }
      | "this"
   { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); }
      | "super"
   { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); }
      | "import"
   { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); }
   )
  )*

  { return ret; }
}


List ClassOrInterfaceTypeList():
{
	List ret = new LinkedList();
	ClassOrInterfaceType type;
	List annotations= null;
	AnnotationExpr ann;
}
{
  (ann = Annotation()   { annotations = add(annotations, ann);  })* type = ClassOrInterfaceType() { type.setAnnotations(annotations); ret.add(type); annotations=null;}  ( "," (ann = Annotation()   { annotations = add(annotations, ann);  })* type = ClassOrInterfaceType() { type.setAnnotations(annotations); ret.add(type); annotations=null;} )*

  { return ret; }
}

NameExpr SimpleName():
{
    NameExpr ret;
}
{
  <IDENTIFIER> { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image); }
  { return ret; }
}

List NameList():
{
	List ret = new LinkedList();
	NameExpr name;
}
{
  name = Name() { ret.add(name); }  ( "," name = Name() { ret.add(name); } )*

  { return ret; }
}


/*
 * Expression syntax follows.
 */

Expression Expression():
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
	Expression ret;
	AssignExpr.Operator op;
	Expression value;
	Statement lambdaBody = null;
	List params = null;
	List typeArgs = null;
	VariableDeclaratorId id = null;
	Expression inner = null;
}
{
  ret = ConditionalExpression()
  [
    (
       LOOKAHEAD(2)
    op = AssignmentOperator() value = Expression() { ret = new AssignExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, value, op); }
  |
   "->" lambdaBody = LambdaBody()
   {
     if (ret instanceof CastExpr)
     {
       inner = generateLambda(((CastExpr)ret).getExpr(), lambdaBody);
       ((CastExpr)ret).setExpr(inner);
     }
     else if (ret instanceof ConditionalExpr){
     	 ConditionalExpr ce = (ConditionalExpr) ret;
         if(ce.getElseExpr() != null){
            ce.setElseExpr(generateLambda(ce.getElseExpr(), lambdaBody));
         }
     }
     else
     {
       ret = generateLambda(ret, lambdaBody);
     }
   }
 |  "::"  [typeArgs = TypeParameters() {typeArgs.remove(0);} ] (<IDENTIFIER> | "new")
 {
   ret = new MethodReferenceExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, token.image);
 }
   )
  ]

  { return ret; }
}

AssignExpr.Operator AssignmentOperator():
{
	AssignExpr.Operator ret;
}
{
  (
      "="    { ret = AssignExpr.Operator.assign; }
    | "*="   { ret = AssignExpr.Operator.star; }
    | "/="   { ret = AssignExpr.Operator.slash; }
    | "%="   { ret = AssignExpr.Operator.rem; }
    | "+="   { ret = AssignExpr.Operator.plus; }
    | "-="   { ret = AssignExpr.Operator.minus; }
    | "<<="  { ret = AssignExpr.Operator.lShift; }
    | ">>="  { ret = AssignExpr.Operator.rSignedShift; }
    | ">>>=" { ret = AssignExpr.Operator.rUnsignedShift; }
    | "&="   { ret = AssignExpr.Operator.and; }
    | "^="   { ret = AssignExpr.Operator.xor; }
    | "|="   { ret = AssignExpr.Operator.or; }
  )
  { return ret; }
}

Expression ConditionalExpression():
{
	Expression ret;
	Expression left;
	Expression right;
}
{
  ret = ConditionalOrExpression()
  [ "?" left = Expression() ":" right = ConditionalExpression() { ret = new ConditionalExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, left, right); } ]
  { return ret; }
}

Expression ConditionalOrExpression():
{
	Expression ret;
	Expression right;
}
{
  ret = ConditionalAndExpression() ( "||" right = ConditionalAndExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.or); } )*
  { return ret; }
}

Expression ConditionalAndExpression():
{
	Expression ret;
	Expression right;
}
{
  ret = InclusiveOrExpression() ( "&&" right = InclusiveOrExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.and); } )*
  { return ret; }
}

Expression InclusiveOrExpression():
{
	Expression ret;
	Expression right;
}
{
  ret = ExclusiveOrExpression() ( "|" right = ExclusiveOrExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.binOr); } )*
  { return ret; }
}

Expression ExclusiveOrExpression():
{
	Expression ret;
	Expression right;
}
{
  ret = AndExpression() ( "^" right = AndExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.xor); } )*
  { return ret; }
}

Expression AndExpression():
{
	Expression ret;
	Expression right;
}
{
  ret = EqualityExpression() ( "&" right = EqualityExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.binAnd); } )*
  { return ret; }
}

Expression EqualityExpression():
{
	Expression ret;
	Expression right;
	BinaryExpr.Operator op;
}
{
  ret = InstanceOfExpression()
  (
    ( "==" { op = BinaryExpr.Operator.equals; } |
      "!=" { op = BinaryExpr.Operator.notEquals; }
    ) right = InstanceOfExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
  )*
  { return ret; }
}

Expression InstanceOfExpression():
{
	Expression ret;
	Type type;
}
{
  ret = RelationalExpression() [ "instanceof" type = Type() { ret = new InstanceOfExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, type); } ]
  { return ret; }
}

Expression RelationalExpression():
{
	Expression ret;
	Expression right;
	BinaryExpr.Operator op;
}
{
  ret = ShiftExpression()
  (
  	( "<"  { op = BinaryExpr.Operator.less; } |
  	  ">"  { op = BinaryExpr.Operator.greater; } |
  	  "<=" { op = BinaryExpr.Operator.lessEquals; } |
  	  ">=" { op = BinaryExpr.Operator.greaterEquals; }
  	) right = ShiftExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
  )*
  { return ret; }
}

Expression ShiftExpression():
{
	Expression ret;
	Expression right;
	BinaryExpr.Operator op;
}
{
  ret = AdditiveExpression()
  (
  	( "<<"             { op = BinaryExpr.Operator.lShift; } |
  	  RSIGNEDSHIFT()   { op = BinaryExpr.Operator.rSignedShift; } |
  	  RUNSIGNEDSHIFT() { op = BinaryExpr.Operator.rUnsignedShift; }
  	) right = AdditiveExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
  )*
  { return ret; }
}

Expression AdditiveExpression():
{
	Expression ret;
	Expression right;
	BinaryExpr.Operator op;
}
{
  ret = MultiplicativeExpression()
  (
  	( "+" { op = BinaryExpr.Operator.plus; } |
  	  "-" { op = BinaryExpr.Operator.minus; }
  	) right = MultiplicativeExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
  )*
  { return ret; }
}

Expression MultiplicativeExpression():
{
	Expression ret;
	Expression right;
	BinaryExpr.Operator op;
}
{
  ret = UnaryExpression()
  (
  	( "*" { op = BinaryExpr.Operator.times; } |
  	  ( LOOKAHEAD( {
  	  "/".equals(getToken(1).image) &&
  	   (
  	       !getToken(2).image.startsWith(">")
  	       && !(getToken(2).kind == IDENTIFIER && getToken(3).image.equals(">"))
  	   )
  	   } )
  	  "/" { op = BinaryExpr.Operator.divide; }
  	   )|
  	  "%" { op = BinaryExpr.Operator.remainder; }
  	) right = UnaryExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
  )*
  { return ret; }
}

Expression UnaryExpression():
{
	Expression ret;
	UnaryExpr.Operator op;
	int line = 0;
	int column = 0;
}
{
  (
	  ret = PreIncrementExpression()
	|
	  ret = PreDecrementExpression()
	|
	  ( "+" { op = UnaryExpr.Operator.positive; line=token.beginLine; column=token.beginColumn;} |
	    "-" { op = UnaryExpr.Operator.negative; line=token.beginLine; column=token.beginColumn;}
	  ) ret = UnaryExpression()
	  {
	  	 if(op == UnaryExpr.Operator.negative) {
	  	 	if (ret instanceof IntegerLiteralExpr && ((IntegerLiteralExpr)ret).isMinValue()) {
	  	 		ret = new IntegerLiteralMinValueExpr(line, column, token.endLine, token.endColumn);
	  	 	} else if (ret instanceof LongLiteralExpr && ((LongLiteralExpr)ret).isMinValue()) {
	  	 		ret = new LongLiteralMinValueExpr(line, column, token.endLine, token.endColumn);
	  	 	} else {
	  	 		ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
	  	 	}
	  	 } else {
	  	 	ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
	  	 }
	  }
	|
	  ret = UnaryExpressionNotPlusMinus()
  )
  { return ret; }
}

Expression PreIncrementExpression():
{
	Expression ret;
	int line;
	int column;
}
{
  "++" {line=token.beginLine; column=token.beginColumn;} ret = UnaryExpression() { ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, UnaryExpr.Operator.preIncrement); }
  { return ret; }
}

Expression PreDecrementExpression():
{
	Expression ret;
	int line;
	int column;
}
{
  "--" {line=token.beginLine; column=token.beginColumn;} ret = UnaryExpression() { ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, UnaryExpr.Operator.preDecrement); }
  { return ret; }
}

Expression UnaryExpressionNotPlusMinus():
{
	Expression ret;
	UnaryExpr.Operator op;
	int line = 0;
	int column = 0;
}
{
  (
	  ( "~" { op = UnaryExpr.Operator.inverse; line=token.beginLine; column=token.beginColumn;} |
	    "!" { op = UnaryExpr.Operator.not;     line=token.beginLine; column=token.beginColumn;}
	  ) ret = UnaryExpression() { ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op); }
	|
	  LOOKAHEAD( CastExpression() )
	  ret = CastExpression()
	|
      ret = PostfixExpression()
  )
  { return ret; }
}

Expression PostfixExpression():
{
	Expression ret;
	UnaryExpr.Operator op;
}
{
  ret = PrimaryExpression()
  [
  	LOOKAHEAD(2)
    ( "++" { op = UnaryExpr.Operator.posIncrement; } |
      "--" { op = UnaryExpr.Operator.posDecrement; }
    ) { ret = new UnaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, op); }
  ]
  { return ret; }
}

Expression CastExpression():
{
	Expression ret;
	Type type;
	int line;
	int column;
	AnnotationExpr ann;
	Type st;
	List annotations = null;
	List typesOfMultiCast = null;
	boolean isMulti = false;
}
{
  "(" {line=token.beginLine; column=token.beginColumn;}
   (ann = Annotation()   { annotations = add(annotations, ann);})*
  (
  	  LOOKAHEAD(2)
  	  type = PrimitiveType() ")" ret = UnaryExpression() { type.setAnnotations(annotations); ret = new CastExpr(line, column, token.endLine, token.endColumn, type, ret); }
  	|
  	  type = ReferenceType() { typesOfMultiCast = add(typesOfMultiCast, type); type.setAnnotations(annotations); }
  	  ( "&" type = ReferenceType() {
  	    typesOfMultiCast = add(typesOfMultiCast, type);
  	    }
  	  )*
  	  ")" ret = UnaryExpressionNotPlusMinus() {
  	    if (typesOfMultiCast.size() > 1) {
  	        type = new IntersectionType(line, column, token.endLine, token.endColumn, typesOfMultiCast);
  	    }
  	    ret = new CastExpr(line, column, token.endLine, token.endColumn, type, ret);
  	  }
 )
  { return ret; }
}



Expression PrimaryExpression():
{
	Expression ret;
	Expression inner;
}
{
  ret = PrimaryPrefix() ( LOOKAHEAD(2) ret = PrimarySuffix(ret) )*
  { return ret; }
}

Expression PrimaryExpressionWithoutSuperSuffix():
{
	Expression ret;
	Expression inner;
}
{
  ret = PrimaryPrefix() ( LOOKAHEAD( PrimarySuffixWithoutSuper(null) ) ret = PrimarySuffixWithoutSuper(ret) )*
  { return ret; }
}

Expression PrimaryPrefix():
{
	Expression ret = null;
	NameExpr name;
	List typeArgs = null;
	List args = null;
	boolean hasArgs = false;
	boolean isLambda = false;
	Type type;
	int line;
	int column;
	Parameter p = null;
	VariableDeclaratorId id = null;
}
{
  (
	  ret = Literal()
	|
	  "this" { ret = new ThisExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, null); }
	|
	  "super" { ret = new SuperExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, null); }
	  (
	     "."
	  [ typeArgs = TypeArguments() {typeArgs.remove(0);} ]
	  name = SimpleName()
	  [ args = Arguments() {hasArgs=true;} ]
	  	{
			if (hasArgs) {
	  			MethodCallExpr m = new MethodCallExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, null, args);
				m.setNameExpr(name);
				ret = m;
			} else {
	  			FieldAccessExpr f = new FieldAccessExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, null, null);
				f.setFieldExpr(name);
				ret = f;
			}
	  	}
	 |
		"::" [typeArgs = TypeParameters() { typeArgs.remove(0); }] (<IDENTIFIER> | "new")
		{
		  ret = new MethodReferenceExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, token.image);
		}
     |   args = Arguments() {new MethodCallExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, null, args);}
	  )
	|

	  "(" {line=token.beginLine; column=token.beginColumn;}
	  	[
	  	( LOOKAHEAD(FormalParameter()) p = FormalParameter() { isLambda = true;} [args = FormalLambdaParameters()]
	  	| ret = Expression() [args = InferredLambdaParameters() { isLambda = true;} ]
	  	)
	  	]
	  	")"
	  	{
	  		   if(!isLambda) { ret = new EnclosedExpr(line, column, token.endLine, token.endColumn,ret);}
	  		   else{
	  		 	  if(ret != null){
	  		  		  if(ret instanceof NameExpr)
	  		  		  {
	  		  		    id = new VariableDeclaratorId(ret.getBeginLine(), ret.getBeginColumn(), ret.getEndLine(), ret.getEndColumn(), ((NameExpr)ret).getName(), 0);
	  		  		    p = new Parameter(ret.getBeginLine(), ret.getBeginColumn(), ret.getEndLine(), ret.getEndColumn(), 0, null, new UnknownType(), false, id);
	  		  		  }

	  		  		}
	  		  		args = add(0, args, p);
	  		  		ret = new LambdaExpr(p.getBeginLine(), p.getBeginColumn(), token.endLine, token.endColumn, args, null, true);
	  		 	}

	  		 }
	|
	  ret = AllocationExpression(null)
	|
	  LOOKAHEAD( ResultType() "." "class" )
	  type = ResultType()  "." "class" { ret = new ClassExpr(type.getBeginLine(), type.getBeginColumn(), token.endLine, token.endColumn, type); }

	| LOOKAHEAD (ResultType() "::" )
	  type = ResultType() "::" [typeArgs = TypeParameters() { typeArgs.remove(0); }] (<IDENTIFIER> | "new")
		{
		  ret = new TypeExpr(type.getBeginLine(), type.getBeginColumn(), type.getEndLine(), type.getEndColumn(), type);
		  ret = new MethodReferenceExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, token.image);
		}

	|
	  	name = SimpleName() { line=token.beginLine; column=token.beginColumn; }
	  	[ args = Arguments() {hasArgs=true;} ]
	  	{
	  		if (hasArgs) {
	  			MethodCallExpr m = new MethodCallExpr(line, column, token.endLine, token.endColumn, null, null, null, args);
				m.setNameExpr(name);
				ret = m;
			} else {
	  			ret = name;
			}
	  	}
  )
  { return ret; }
}

Expression PrimarySuffix(Expression scope):
{
	Expression ret;
}
{
  (
  	LOOKAHEAD(2)
	ret = PrimarySuffixWithoutSuper(scope)
	|
  	"." "super" { ret = new SuperExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope); }
  )
  { return ret; }
}

Expression PrimarySuffixWithoutSuper(Expression scope):
{
	Expression ret;
	List typeArgs = null;
	List args = null;
	boolean hasArgs = false;
	NameExpr name;
}
{
  (
  	"."
  	(
		"this" { ret = new ThisExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope); }
	  |
	  	ret = AllocationExpression(scope)
	  |
	  	LOOKAHEAD( [ TypeArguments() ] <IDENTIFIER> )
	  	[ typeArgs = TypeArguments() {typeArgs.remove(0);} ]
	  	name = SimpleName()
	  	[ args = Arguments() {hasArgs=true;} ]
	  	{
			if (hasArgs) {
	  			MethodCallExpr m = new MethodCallExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, null, args);
				m.setNameExpr(name);
				ret = m;
			} else {
	  			FieldAccessExpr f =  new FieldAccessExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, null);
				f.setFieldExpr(name);
				ret = f;
			}
	  	}
	)
	|
	  "["ret = Expression() "]" { ret = new ArrayAccessExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, ret); }
  )
  { return ret; }
}

UiContainerExpr RootUiContainer():
{
  String doctype = null;
  UiContainerExpr expr;
}
{
   ( <DOCTYPE> <IDENTIFIER> {
     doctype = token.image;
   } ">")?
  expr = UiContainer()
  {
    if (doctype != null) {
      expr.setDocType(doctype);
    }
    return expr;
  }
}
UiContainerExpr UiContainer():
{
  NameExpr tagName;
  NameExpr endTagName = null;
  List<UiAttrExpr> attrs = new ArrayList();
  UiAttrExpr attr;
  UiBodyExpr body = null;
  int beginLine;
  int beginColumn;
  int endLine;
  int endColumn;
  boolean isInTemplate = false;
}{

   (
     (
       <UI_COMMENT> {
         beginLine = token.beginLine; beginColumn = token.beginColumn;
       }
       ( <UI_COMMENT_BODY>{
            attr = new UiAttrExpr(new NameExpr("value"), false, new StringLiteralExpr(token.image));
            attrs.add(attr);
       } ) *
       <END_UI_COMMENT> {
        endLine = token.endLine; endColumn = token.endColumn;
        tagName = new NameExpr(NameExpr.COMMENT_NAME);
        body = new UiBodyExpr(beginLine, beginColumn + 4, endLine, endColumn - 3, new ArrayList());
        return new UiContainerExpr(beginLine, beginColumn, endLine, endColumn, tagName, attrs, body, isInTemplate);
       }
     ) |
     "<" {
      beginLine = token.beginLine; beginColumn = token.beginColumn;
     }
   )
   tagName = TagName()

   // TODO: If there is a "/" next, we want to load a foreign parser...
   // as in: <ele wti =
   //                 <wti/ (Valid wti using)->{
   //                      a registered foreign parser, named "wti",
   //                      with text that cannot contain /wti > (without the space)
   //                      }
   //                 /wti>
   //        /ele>

   ( attr = UiAttr() { attrs.add(attr); } ) *
    (
      (
        // allow \\ (two backslash) for auto-closing tags, precisely _because_ it's not a valid part of java expressions.
        // This can be necessary for disambiguation between the final attribute, and the end of the tag expression.
        // like: `<tag attr=()->doStuff /tag>...`.  This ambiguity is solved with: `<tag attr=()->doStuff \tag>...`
        ( "/" | "\\\\" )
        [endTagName = TagName() {
          if (!tagName.equals(endTagName)) {
            throw new ParseException("Mismatched start/end tags: " + tagName + " != " + endTagName + " on line " + token.beginLine + " image: " + token.image);
          }
        }]
        (
          ">`"{ isInTemplate = true; endLine = token.endLine; endColumn = token.endColumn; }
         | ">" {
            endLine = token.endLine; endColumn = token.endColumn;
         }
        )
      )
     | (
          // allow an optional single backslash \ before the > in a tag-with-a-body,
          // to allow for disambiguation from preceding java expressions:
          // <tag attr=()->doStuff \>12</tag>
          [
            "\\"
            // also allow for optional closing tagname when using \,
            // as elements-with-bodies are most likely to benefit from "mismatched structure" error avoidance:
            // i.e: <tag1 children = { some: huge(pile, of, code) } \tag1>
            // <many children=ofTag1 \\many>
            // </tag1>
            // If a mismatch tries to swallow any \\close> or \tags> (versus `/>` and `>` respectively),
            // it will fail _in the correct place_ (avoid getting junk errors later when trying to grab ast from wrong node type)
            [endTagName = TagName() {
              if (!tagName.equals(endTagName)) {
                throw new ParseException("Mismatched start/end tags: " + tagName + " != " + endTagName + " on line " + token.beginLine + " image: " + token.image);
              }
            }]

          ]
           ">"
           body = UiBody()
           "</" endTagName = TagName() {
                if (!tagName.equals(endTagName)) {
                    throw new ParseException("Mismatched start/end tags: " + tagName + " != " + endTagName + " on line " + token.beginLine + " image: " + token.image);
                }
           }
           (
           ">`" { isInTemplate = true; endLine = token.endLine; endColumn = token.endColumn; }
         | ">" { endLine = token.endLine; endColumn = token.endColumn; }
           )
       )
    )

{
   UiContainerExpr xapi = new UiContainerExpr(beginLine, beginColumn, endLine, endColumn, tagName, attrs, body, isInTemplate);
   if (endTagName != null && body == null) {
     xapi.alwaysRenderClose();
   }
   return xapi;
 }
}


UiBodyExpr UiBody():
{
  UiContainerExpr el;
  Expression value;
  List<Expression> children = new ArrayList();
  String comment = null;
  int beginLine = -1;
  int beginColumn = -1;
  int endLine = -1;
  int endColumn = -1;
}{
   { setState(UI_BODY); }

   (
    (
      <UI_COMMENT> {
        beginLine = token.beginLine; beginColumn = token.beginColumn;
      }
      ( <UI_COMMENT_BODY> {
           comment = token.image;
      } ) *
      <END_UI_COMMENT> {
       if (comment != null) {
           endLine = token.endLine; endColumn = token.endColumn;
           NameExpr tagName = new NameExpr(NameExpr.COMMENT_NAME);
           UiBodyExpr body = new UiBodyExpr(beginLine, beginColumn + 4, endLine, endColumn - 3, new ArrayList());
           UiAttrExpr attr = new UiAttrExpr(new NameExpr("value"), false, new TemplateLiteralExpr(
           beginLine, beginColumn, endLine, endColumn, comment
           ));
           List attrs = Collections.singletonList(attr);
           children.add(new UiContainerExpr(beginLine, beginColumn, endLine, endColumn, tagName, attrs, body, false));
           setState(UI_BODY);
           comment = null;
       }
      }

   ) | (

     <LT> {
      token_source.backup(1);
      token_source.SwitchTo(DEFAULT);
     }
     el = UiContainer() {
        if (beginLine == -1) {
          beginLine = el.getBeginLine();
          beginColumn  = el.getBeginColumn();
        }
        endLine = el.getEndLine();
        endColumn = el.getEndColumn();
        children.add(el);
        setState(UI_BODY);
     }

//   ) | (
    // Need to remove the need for lexical scope so we can do this...
//     value = UiValue() {
//        children.add(value);
//     }
   ) | (

     <UI_TEXT> {
       if (beginLine == -1) {
         beginLine = token.beginLine;
         beginColumn = token.beginColumn;
       }
       endLine = token.endLine;
       endColumn = token.endColumn;
       if (!token.image.trim().isEmpty()) {
         children.add(new TemplateLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image));
       }
     }

   )
 ) *
 <END_UI_BODY>
{
 setState(DEFAULT);
 return new UiBodyExpr(beginLine, beginColumn, endLine, endColumn, children);
}
}


UiAttrExpr UiAttr():
{
     UiAttrExpr ret = null;
  	NameExpr name;
  	int line = -1;
  	int column = -1;
  	boolean isAttribute = false;
  	Expression expression;
     List annotations = new ArrayList();
     AnnotationExpr annotation = null;
     Map jsonValues = new HashMap();
     NameExpr nextName;
 }{
    (
        // Optional: start an <elements @attributeName="with @ to map to string attributes" />
//        [ "@" {
//            isAttribute = true;
//            line=token.beginLine;
//            column=token.beginColumn;
//        } ]
        name = FeatureName() {
            if (!isAttribute) {
                line=token.beginLine;
                column=token.beginColumn;
            }
        }
        "=" (

          // Grab annotations on the values; @value = "asd" uses html attribute mapping, so `@value = @NotNull "asd"` is where the annotations go.
          ( LOOKAHEAD( { token_source.isAnnotation(token) } ) annotation = Annotation() { annotations = add(annotations, annotation); } )*

          expression = UiValue()
        )
    )
    {
      assert line != -1;
      assert column != -1;
      UiAttrExpr attr = new UiAttrExpr(line, column, token.endLine, token.endColumn,name, isAttribute, expression);
      attr.setAnnotations(annotations);
      return attr;
    }
}

Expression UiValue():
{
    Expression expression;
    BodyDeclaration member;
    List annotations = new ArrayList();
    AnnotationExpr annotation;
    Integer line = null;
    int column = 0;
}
{
(

      LOOKAHEAD( { token_source.isAnnotation(token) } )
      (
        // expect @Annotations followed by a DynamicDeclarationExpr.  Only dynamic members may have annotations (at this time).
        ( LOOKAHEAD( { token_source.isAnnotation(token) } ) annotation = Annotation() {
                annotations = add(annotations, annotation);
                if (line == null) {
                  line = annotation.getBeginLine();
                  column = annotation.getBeginColumn();
                }
              } )*
            member = ClassOrInterfaceBodyDeclaration(true) {
                expression = new DynamicDeclarationExpr(member, annotations);
            }
      )
      |
        LOOKAHEAD( { token_source.isMemberBody(token) } )
      (
        member = ClassOrInterfaceBodyDeclaration(true)
        {
          expression = new DynamicDeclarationExpr(member);
        }

      )
      |

        LOOKAHEAD( { token_source.looksLikeCssSelector(token) } )
      (
        {
          int oldState = token_source.setState(CSS_BODY);
        }
        (
          try {
          // .{  #block { of: css; }  } OR .{ inline: style-rules }
          ( expression = CssBlock())
          |
          // .single { css : rule; }
           ( expression = CssContainer())
          } finally {
            { token_source.setState(oldState); }
          }
          )
      )
      |

      // { json : "object" }.  For blocks of java, use a lambda ()->{}
      LOOKAHEAD( { token_source.looksLikeJson(token) } )
      ( expression = JsonContainer() ) |

      // < block of="ui" />
      ( expression = UiContainer() ) |

      // Any valid, simple java construct (including lambdas and method references).
      expression = FeatureExpression()
)
{ return expression; }
}

Expression FeatureExpression():
{
  Expression expr;
  Expression qualify;
  NameExpr methodName;
  Statement statement;

  List typeArgs = null;
  List args = null;
}
{
(
    (
        (
    // Check for parentheticals, as they will be used to resolve any ambiguous expressions
              LOOKAHEAD({ getToken(1).image.startsWith("(") })
              expr = Expression()
        )
        (
          "->" statement = LambdaBody()
          { expr = generateLambda(expr, statement); }
        )?
        (
        "::"
          [typeArgs = TypeParameters() { typeArgs.remove(0); } ] (<IDENTIFIER > | "new")
          { expr = new MethodReferenceExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, typeArgs, token.image); }

        )?
    )
    | LOOKAHEAD({
        ( getToken(1).kind == IDENTIFIER || getToken(1).kind == FEATURE_IDENTIFIER )
        && token_source.looksLikeMethodOrLambda()
        })
        (
            expr = FeatureName()
        )
        [
        (
          "->" statement = LambdaBody()
          { expr = generateLambda(expr, statement); }

        ) | (

        "::"
          [typeArgs = TypeParameters() { typeArgs.remove(0); } ] (<IDENTIFIER > | "new")
          { expr = new MethodReferenceExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, typeArgs, token.image); }

        ) | (

          [ typeArgs = TypeParameters() { typeArgs.remove(0); } ]
          args = Arguments()
          {
            // TODO: handle case where there is a call().moreCalls()
            NameExpr scope;
            if (expr instanceof QualifiedNameExpr) {
              QualifiedNameExpr qualified = (QualifiedNameExpr) expr;
              scope = qualified.getQualifier();
            } else {
              scope = null;
            }
            MethodCallExpr m = new MethodCallExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, null, args);
            m.setNameExpr((NameExpr)expr);
            expr = m;
          }
          // TODO: actually grab up call().suffix() chains properly...
          (
            "." qualify = FeatureExpression() {
                if (qualify instanceof MethodCallExpr) {
                  ((MethodCallExpr)qualify).setScope(expr);
                  expr = qualify;
                } else {
                  throw new UnsupportedOperationException("Cannot handle " + qualify.getClass() + " : " + qualify);
                }
            }
          )*
        )
        ]

    | expr = UiStatement()

    // The only expressions we allow outside of parentheticals are simple;
    // Either a singleArg->lambda(), ref::methodRef, "String", AnyName, numbers or boolean.
    )
    {return expr;}
}

Expression UiStatement():
{
  ExpressionStmt statement;
  Expression expr, nextExpr;
  Type type;
}
{
  (
    LOOKAHEAD( Expression() ";" ) ( expr = Expression() ";" { return expr; } )
    | (
        expr = FeatureName()

        ( "[" "]" {
           if (expr instanceof NameExpr) {
              ClassOrInterfaceType asCls = new ClassOrInterfaceType(((NameExpr)expr).getQualifiedName());
              expr = new TypeExpr(new ReferenceType(asCls, 1));
           } else if (expr instanceof TypeExpr) {
              ReferenceType refType = (ReferenceType)((TypeExpr)expr).getType();
              refType.setArrayCount(refType.getArrayCount()+1);
           } else {
              throw new IllegalArgumentException(
                "Cannot handle a non-name, non-reference type expression "
                  + expr + " of type " + expr.getClass() );
           }
        } )*
        (
          "."
          nextExpr = UiStatement() {
            if (nextExpr instanceof ScopedExpression) {
              ScopedExpression scope = (ScopedExpression)nextExpr;
              scope.getRoot().setScope(expr);
              expr = nextExpr;
            } else if (nextExpr instanceof NameExpr) {
              NameExpr nextName = (NameExpr)nextExpr;
              if (expr instanceof NameExpr) {
                expr = new QualifiedNameExpr((NameExpr)expr, nextName.getName());
              } else if (expr instanceof TypeExpr) {
                  TypeExpr exprType = (TypeExpr)expr;
                  if ("class".equals(nextName.getName())) {
                    return new ClassExpr(exprType.getType());
                  }
                  if (Character.isLowerCase(nextName.getName().charAt(0))) {
                    // treat this as a field reference.
                    FieldAccessExpr asField = new FieldAccessExpr(expr, nextName.getName());
                    expr = asField;
                  } else {
                    // Treat this as a type reference
                    if (! (exprType.getType() instanceof ClassOrInterfaceType) ) {
                      throw new ParseException("Illegal nested type. type " + expr + "." + nextExpr + " is invalid");
                    }
                    ClassOrInterfaceType asClass = (ClassOrInterfaceType)exprType.getType();
                    ClassOrInterfaceType nested = new ClassOrInterfaceType(asClass, nextName.getName());
                    expr = new TypeExpr(nested);
                  }
              } else {
                  throw new ParseException("Unhandled . reference in " + expr + " :: " + nextExpr);
              }
            } else {
              throw new ParseException("Unhandled . reference in " + expr + " :: " + nextExpr);
            }
          }
        )*
      )
    | expr = Literal()
    | type = Type() {
      expr = new TypeExpr(type);
    }
  )
  { return expr; }
}

JsonContainerExpr JsonContainer():
{
  List items = new ArrayList();
  JsonPairExpr pair = null;
  Expression value;
  boolean isArray = false;
  Integer line = null;
  int column = 0;
  int cnt = 0;
}{
    (
    "{" {
      if (line == null) {
        line = token.beginLine;
        column = token.beginColumn;
      }
    }

    // First, an item [optional]
    [ pair = JsonPair() { items.add(pair); } ]
    [
      ( LOOKAHEAD( { token_source.isCommaCloseJson(token)} ) "," )
      |
      // Next, optionally, N `, name:expr()`s
      (
        LOOKAHEAD( { token_source.isCommaNotTrailing(token) } )
        ( "," pair = JsonPair() { items.add(pair); } )
      ) +
    ]
    // Finally, an optional trailing ,
    [ "," ]

    "}" {
      return new JsonContainerExpr(line, column, token.endLine, token.endColumn, false, items);
    } )
    | (
    "[" {
      line = token.beginLine;
      column = token.beginColumn;
    }

    // First, an item [optional]
    [ JsonSingle(items, true) ]
    [
      // Next, optionally, N `, expr()`s
      (
        ( LOOKAHEAD( { token_source.isCommaNotTrailing(token) } )
         "," JsonSingle(items, false) )
      )+
    ]
    // Finally, an optional trailing ,
    [ "," ]

    "]" )

  { return new JsonContainerExpr(line, column, token.endLine, token.endColumn, true, items); }
}

JsonPairExpr JsonSingle(List items, boolean first):
{
  Integer line = null;
  int column = 0;
  Expression value;
  AnnotationExpr annotation;
  List annotations = new ArrayList();
}
{
(
      ( LOOKAHEAD( { token_source.isAnnotation(token) } ) annotation = Annotation() {
        annotations = add(annotations, annotation);
        if (line == null) {
          line = annotation.getBeginLine();
          column = annotation.getBeginColumn();
        }
      } )*

       value = UiValue()

  )
  {
    IntegerLiteralExpr key = new IntegerLiteralExpr(Integer.toString(items.size()));
    if (line == null) {
      line = value.getBeginLine();
      column = value.getBeginColumn();
    }
    JsonPairExpr pair = new JsonPairExpr(
                          line,
                          column,
                          value.getEndLine(),
                          value.getEndColumn(),
                          key, value
                   );
    pair.setAnnotations(annotations);
    items.add(pair);
    return pair;
  }
}

JsonPairExpr JsonPair():
{
  Integer line = null;
  int column = -1;
  Expression name;
  Expression value;
  AnnotationExpr annotation;
  List annotations = new ArrayList();
}
{
(
      (
      ( LOOKAHEAD( { token_source.isAnnotation(token) } ) annotation = Annotation() {
        annotations = add(annotations, annotation);
        if (line == null) {
          line = annotation.getBeginLine();
          column = annotation.getBeginColumn();
        }
      } )*
      (
        name = SimpleName() {
            if (line == null) {
              line = name.getBeginLine();
              column = name.getBeginColumn();
            }
        } |
        name = Literal() {
            if (line == null) {
              line = name.getBeginLine();
              column = name.getBeginColumn();
            }
        } |
        name = Expression() {
            if (line == null) {
              line = name.getBeginLine();
              column = name.getBeginColumn();
            }
        }
      )
      ":"
       (
            value = SimpleName() | value = Literal() | value = UiValue()
       )
      )
  )
  {
    JsonPairExpr pair = new JsonPairExpr(line, column, token.endLine, token.endColumn, name, value);
    pair.setAnnotations(annotations);
    return pair;
  }
}

CssBlockExpr CssBlock():
{
  List containers = new ArrayList();
  CssContainerExpr container;
  List rules = new ArrayList();
  CssRuleExpr rule;
  int line;
  int column;
}
{
  (
    (
      // :{ display: inline; }
      <START_CSS_INLINE> {
        line = token.beginLine;
        column = token.beginColumn;
      }
      (
        rule = CssRule() { rules.add(rule); }
      )+
      {
         container = new CssContainerExpr(line, column, token.endLine, token.endColumn, new ArrayList(), rules);
         containers.add(container);
      }
    )
    |
    (
      // .{ $class { display: inline; } }
      <START_CSS_BLOCK> {
        line = token.beginLine;
        column = token.beginColumn;
      }
      (
        container = CssContainer() { containers.add(container); }
      ) +
    )
  )
  "}"
  { return new CssBlockExpr(line, column, token.endLine, token.endColumn, containers); }
}

CssContainerExpr CssContainer():
{
  List selectors = new ArrayList();
  List rules = new ArrayList();
  int line;
  int column;
  CssSelectorExpr selector;
  CssRuleExpr rule;
  int oldState = token_source.setState(CSS_BODY);
}
{
  try {
  ( selector = CssSelector() {
        line = selector.getBeginLine();
        column = selector.getBeginColumn();
        selectors.add(selector);
    }
    ( "," selector = CssSelector() { selectors.add(selector); } ) *
    "{"
    ( rule = CssRule() { rules.add(rule); } ) *
    "}"
   )
   } finally {
     { token_source.setState(oldState); }
   }
  { return new CssContainerExpr(line, column, token.endLine, token.endColumn, selectors, rules); }
}

CssSelectorExpr CssSelector():
{
  List parts = new ArrayList();
  String part;
  int line;
  int column;
}
{
  (
    (
    // TODO make each token an object w/ begin and end source info?
    <CSS_SELECTOR> {
        parts.add(token.image);
        line = token.beginLine;
        column = token.beginColumn;
    } | <FEATURE_IDENTIFIER> {
        parts.add(token.image);
        line = token.beginLine;
        column = token.beginColumn;
    } | <IDENTIFIER> {
        parts.add(token.image);
        line = token.beginLine;
        column = token.beginColumn;
    } | "*" {
        parts.add(token.image);
        line = token.beginLine;
        column = token.beginColumn;
    }
    )
    (
       "::" { parts.add(token.image); }
     | <CSS_SELECTOR> { parts.add(token.image); }
     | <FEATURE_IDENTIFIER> { parts.add(token.image); }
     | <IDENTIFIER> { parts.add(token.image); }
     | <CSS_SELECTOR_JOIN> { parts.add(token.image); }
     | "*" { parts.add(token.image); }
     )*

  )
  { return new CssSelectorExpr(line, column, token.endLine, token.endColumn, parts); }
}

CssRuleExpr CssRule():
{
  Expression key;
  Expression value;
  ExpressionStmt stmt;
  int line;
  int column;
}
{
  (
    (
      <CSS_KEY> {
        line = token.beginLine;
        column = token.beginColumn;
        key = new TemplateLiteralExpr(line, column, token.endLine, token.endColumn, token.image);
      }
    )
    | (
      <IDENTIFIER> {
        line = token.beginLine;
        column = token.beginColumn;
        key = new TemplateLiteralExpr(line, column, token.endLine, token.endColumn, token.image);
      }
    )
    | (
      <FEATURE_IDENTIFIER> {
        line = token.beginLine;
        column = token.beginColumn;
        key = new TemplateLiteralExpr(line, column, token.endLine, token.endColumn, token.image);
      }
    )
    | (
      <CSS_SELECTOR> {
        // TODO validate that we did not pick up an invalid key,
        // as CSS_KEY can be mis-matched as a CssSelector
        line = token.beginLine;
        column = token.beginColumn;
        key = new TemplateLiteralExpr(line, column, token.endLine, token.endColumn, token.image);
      }
    )
    // TODO allow use of expressions only within parens
    |
    (
      "("
      key = UnaryExpression() {
        line = key.getBeginLine();
        column = key.getBeginColumn();
      }
      ")"
    )
  )
  (
    // normal css
    ( ":" ( value = CssExpression() ) )
    // java expressions...
    | ( <BEGIN_DECL> ( stmt = StatementExpression() { value = stmt.getExpression(); } ) )
    // ui expressions (<style>)...
    | (">:" ( value = UiContainer() ) )
  )
  { return new CssRuleExpr(line, column, token.endLine, token.endColumn, key, value); }
}

Expression CssExpression():
{
  Expression value, nextValue;
  String unit = null;
  boolean important = false;
}
{
  value = CssExpressionList()
  [ <IMPORTANT> { important = true; } ]
  ";"
  {
    // This is wrong.  unit used to be grabbed here, now it is always null.
    // We'll want to make a few new ast types: CssValueList, CssValue (just literal and optional unit), CssFunction,
    // and perhaps something other than StatementExpression() to allow lambdas and method references (we want to handle ;)
    value = new CssValueExpr(value, unit, important);
  }
  {
    return value;
  }
}

Expression CssExpressionList():
{
  Expression value, nextValue;
  String extra = " ";
}
{
  ( value = CssExpressionToken() )
  ( ( "," { extra = ","; } )? // space is a SKIP token, so we can just look for * more "space or comma delimited" CssExpressionToken...
   nextValue = CssExpressionToken() {
      // consider actually making a CssExpressionList, for space-separated values...
      // (also consider just using existing css javacc parsers in a switchable fashion)
      value = TemplateLiteralExpr.templateLiteral(value, " " + extra + " ", nextValue);
      extra = " "; // reset to space again, actual commas will reassign the var
  }  )*
  {
    return value;
  }
}

Expression CssExpressionToken():
{
  Expression value, nextValue;
}
{
  (
  // TODO: follow this spec: https://www.w3.org/TR/css-syntax-3/ or adapt closure css compiler
    (
      <HEX_COLOR> {
          value = TemplateLiteralExpr.templateLiteral(token.image);
        }
        // Use $.com.fu.Qualified.staticMethod(...) or whatever Expression you want here.
      | ( <BEGIN_EXPR> value = Expression() )
        // TODO: add $:public String generate(This method) { ... }
        // to inline a generated "method produces a value to put in css"
      | value = FeatureName()
      | ( LOOKAHEAD( { token_source.looksLikeNumber(token) } )
          { boolean negative = false, putBackD = false; }
          ["-"{ negative = true; } ]
           // Literal() here will only grab numbers (may want to extract them for smaller reuse)
          value = Literal() {
            StringLiteralExpr string = (StringLiteralExpr)value;
            String v = string.getValue();
            if (negative) {
              if (!v.startsWith("-")) {
                v = "-" + v;
              }
            }
            putBackD = token.image.toLowerCase().endsWith("d");
            if (putBackD) {
              v = v.substring(0, v.length()-1);
            }
            string.setValue(v);
          }
          [
            <CSS_UNIT> {
                String src = (putBackD ? "d" : "") + token.image; // put back any "d" stolen by matching double literals
                // TODO: better object model that retains knowledge of the discovered unit; CssValueExpr is poorly designed.
                value = TemplateLiteralExpr.templateLiteral(value, src, null, " ");
              }
          ]
        )
      | <CSS_KEY> {
          value = TemplateLiteralExpr.templateLiteral(token.image);
        }
        // catch-all leftovers...
      | value = Literal()
    )
    [
      "(" (
          nextValue = CssExpressionList() {
            // TODO: CssFunctionExpr
            value = TemplateLiteralExpr.templateLiteral(value, "(", nextValue, ") ");
          }
      )? ")"
    ]

    )
  {
    return value;
  }
}

Expression Literal():
{
	Expression ret;
}
{
  (
	  <INTEGER_LITERAL> {
	  		ret = new IntegerLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
	  }
	|
	  <LONG_LITERAL> {
	  		ret = new LongLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
	  }
	|
	  <FLOATING_POINT_LITERAL> {
	  		ret = new DoubleLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
	  }
	|
	  <CHARACTER_LITERAL> {
	  	ret = new CharLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
	  }
	|
	  <STRING_LITERAL> {
	  	ret = new StringLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
	  }
	| (
	   <START_UI>
	   ret = UiBody()
	) {
	  }
	|
	  <TEMPLATE_LITERAL> {
	  	ret = new TemplateLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
	  }
	|
	  ret = BooleanLiteral()
	|
	  ret = NullLiteral()
  )
  { return ret; }
}

Expression BooleanLiteral():
{
	Expression ret;
}
{
  (
	  "true" { ret = new BooleanLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, true); }
	|
	  "false" { ret = new BooleanLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, false); }
  )
  { return ret; }
}

Expression NullLiteral():
{}
{
  "null"
  { return new NullLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
}

List Arguments():
{
	List ret = null;
}
{
  "(" [ ret = ArgumentList() ] ")"
  { return ret; }
}

List ArgumentList():
{
	List ret = new LinkedList();
	Expression expr;
}
{
  expr = Expression() { ret.add(expr); } ( "," expr = Expression() { ret.add(expr); } )*
  { return ret; }
}

Expression AllocationExpression(Expression scope):
{
	Expression ret;
	ArrayCreationExpr arrayExpr;
	Type type;
	Object[] arr = null;
	List typeArgs = null;
	List anonymousBody = null;
	List args;
	int line;
	int column;
	List annotations = null;
	AnnotationExpr ann;
}
{
  "new" { if(scope==null) {line=token.beginLine; column=token.beginColumn;} else {line=scope.getBeginLine(); column=scope.getBeginColumn();} }

  (ann = Annotation()   { annotations = add(annotations, ann);})*
  (
	  type = PrimitiveType() {type.setAnnotations(annotations); }
	  arr = ArrayDimsAndInits()
	  {
	    arrayExpr = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, null, 0);
	    arrayExpr.setArraysAnnotations((List)arr[2]);
	  	if (arr[0] instanceof Integer) {
	  	    arrayExpr.setArrayCount(((Integer)arr[0]).intValue());
	  	    arrayExpr.setInitializer((ArrayInitializerExpr)arr[1]);
	  	} else {
	  	    arrayExpr.setArrayCount(((Integer)arr[1]).intValue());
	  	    arrayExpr.setDimensions((List)arr[0]);
	  	}
	  	ret = arrayExpr;
	  }
	|
	 [ typeArgs = TypeArguments()  (ann = Annotation()   { annotations = add(annotations, ann);})* {typeArgs.remove(0);} ]
	  type = ClassOrInterfaceType()

      (
	      arr = ArrayDimsAndInits() {type.setAnnotations(annotations); arrayExpr = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, null, 0);	  }
		  {
		    arrayExpr.setArraysAnnotations((List)arr[2]);
		  	if (arr[0] instanceof Integer) {
			  	arrayExpr.setArrayCount(((Integer)arr[0]).intValue());
		  	    arrayExpr.setInitializer((ArrayInitializerExpr)arr[1]);
		  	} else {
			  	arrayExpr.setArrayCount(((Integer)arr[1]).intValue());
		  	    arrayExpr.setDimensions((List)arr[0]);
		  	}
		  	ret = arrayExpr;
		  }
	  |
	      args = Arguments() [ LOOKAHEAD(2) anonymousBody = ClassOrInterfaceBody(false) ]
	      { type.setAnnotations(annotations); ret = new ObjectCreationExpr(line, column, token.endLine, token.endColumn, scope, (ClassOrInterfaceType) type, typeArgs, args, anonymousBody); }
      )
  )
  { return ret; }
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
Object[] ArrayDimsAndInits():
{
	Object[] ret = new Object[3];
	Expression expr;
	List inits = null;
	int i = 0;
	List accum = null;
	List annotations = null;
	AnnotationExpr ann;
}
{
  (ann = Annotation()   { annotations = add(annotations, ann);  })*
  (
	  LOOKAHEAD(2)
	  ( LOOKAHEAD(2) "[" expr = Expression() { accum = add(accum, annotations); annotations=null; inits = add(inits, expr); } "]" )+ ( LOOKAHEAD(2) (ann = Annotation()   { annotations = add(annotations, ann);  })* "[" "]" { i++; } )* {  accum = add(accum, annotations); annotations=null; ret[0] = inits; ret[1] = new Integer(i); }
	|
	  ( "[" "]" { i++; } )+ expr = ArrayInitializer() { accum = add(accum, annotations);annotations=null;  ret[0] = new Integer(i); ret[1] = expr; }
  )
  { ret[2]=accum; return ret; }
}


/*
 * Statement syntax follows.
 */

Statement Statement():
{
	Statement ret;
}
{
  (
	  LOOKAHEAD(2)
	  ret = LabeledStatement()
	|
	  ret = AssertStatement()
	|
	  ret = Block()
	|
	  ret = EmptyStatement()
	|
	  ret = StatementExpression()
	|
	  ret = SwitchStatement()
	|
	  ret = IfStatement()
	|
	  ret = WhileStatement()
	|
	  ret = DoStatement()
	|
	  ret = ForStatement()
	|
	  ret = BreakStatement()
	|
	  ret = ContinueStatement()
	|
	  ret = ReturnStatement()
	|
	  ret = ThrowStatement()
	|
	  ret = SynchronizedStatement()
	|
	  ret = TryStatement()
  )
  { return ret; }
}

AssertStmt AssertStatement():
{
	Expression check;
	Expression msg = null;
	int line;
	int column;
}
{
  "assert" {line=token.beginLine; column=token.beginColumn;} check = Expression() [ ":" msg = Expression() ] ";"
  { return new AssertStmt(line, column, token.endLine, token.endColumn,check, msg);  }
}

LabeledStmt LabeledStatement():
{
	String label;
	Statement stmt;
	int line;
	int column;
}
{
  <IDENTIFIER> {line=token.beginLine; column=token.beginColumn;} { label = token.image; } ":" stmt = Statement()
  { return new LabeledStmt(line, column, token.endLine, token.endColumn,label, stmt); }
}

BlockStmt Block():
{
	List stmts;
	int beginLine;
	int beginColumn;
}
{
  "{" {beginLine=token.beginLine; beginColumn=token.beginColumn;}
  	stmts = Statements()
  "}"
  { return new BlockStmt(beginLine, beginColumn, token.endLine, token.endColumn, stmts); }
}

/*
 * Classes inside block stametents can only be abstract or final. The semantic must check it.
 */
Statement BlockStatement():
{
	Statement ret;
	Expression expr;
	ClassOrInterfaceDeclaration typeDecl;
	Modifier modifier;
}
{
  (
	  LOOKAHEAD( Modifiers() ("class" | "interface") )
  	  {  }
	  modifier = Modifiers()
	  typeDecl = ClassOrInterfaceDeclaration(modifier) { ret = new TypeDeclarationStmt(typeDecl.getBeginLine(), typeDecl.getBeginColumn(), token.endLine, token.endColumn, typeDecl); }
	|
  	  LOOKAHEAD(VariableDeclarationExpression() )
	  expr = VariableDeclarationExpression() ";"
	  { ret = new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr); }
    |
	  ret = Statement()
  )
  { return ret; }
}

VariableDeclarationExpr VariableDeclarationExpression():
{
	Modifier modifier;
	Type type;
	List vars = new LinkedList();
	VariableDeclarator var;
}
{
  modifier = Modifiers() type = Type() var = VariableDeclarator() { vars.add(var); } ( "," var = VariableDeclarator() { vars.add(var); } )*
  {
    int line = modifier.beginLine;
    int column = modifier.beginColumn;
    if(line==-1) {line=type.getBeginLine(); column=type.getBeginColumn(); }
    return new VariableDeclarationExpr(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, vars);
  }
}

EmptyStmt EmptyStatement():
{}
{
  ";"
  { return new EmptyStmt(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
}

Statement LambdaBody():
{
  Expression expr;
  Statement n = null;
}
{
  (
  	expr = Expression()
  	{
  	  n = new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr);
  	}
 	|  n = Block()
  )
  {
  	return n;
  }

}

ExpressionStmt StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{
	Expression expr;
	AssignExpr.Operator op;
	Expression value;
	Type type;
	List typeArgs = null;
	Statement lambdaBody = null;
	VariableDeclaratorId id = null;
	List params = null;
	Expression inner = null;
}
{
  ( LOOKAHEAD(2)
	  expr = PreIncrementExpression()
	|
	  expr = PreDecrementExpression()
	|
	  expr = PrimaryExpression()
	  [
	    "++" { expr = new UnaryExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, UnaryExpr.Operator.posIncrement);  }
	  |
	    "--" { expr = new UnaryExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, UnaryExpr.Operator.posDecrement);  }
	  |
	    op = AssignmentOperator() value = Expression() { expr = new AssignExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, value, op); }
	  | "::"  [typeArgs = TypeParameters() { typeArgs.remove(0); } ] (<IDENTIFIER > | "new"){expr = new MethodReferenceExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, typeArgs, token.image); 	  }

	 |
	   "->" lambdaBody = LambdaBody()
	   {
	     if (expr instanceof CastExpr)
	     {
           inner = generateLambda(((CastExpr)expr).getExpr(), lambdaBody);
           ((CastExpr)expr).setExpr(inner);
	     }
	     else
	     {
	       expr = generateLambda(expr, lambdaBody);
	     }
	   }
	  ]
  )
  ";"
  { return new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr); }
}

SwitchStmt SwitchStatement():
{
	Expression selector;
	SwitchEntryStmt entry;
	List entries = null;
	int line;
	int column;
}
{
  "switch" {line=token.beginLine; column=token.beginColumn;} "(" selector = Expression() ")" "{"
    ( entry = SwitchEntry() { entries = add(entries, entry); } )*
  "}"

  { return new SwitchStmt(line, column, token.endLine, token.endColumn,selector, entries); }
}

SwitchEntryStmt SwitchEntry():
{
	Expression label = null;
	List stmts;
	int line;
	int column;
}
{
  (
	  "case" {line=token.beginLine; column=token.beginColumn;} label = Expression()
	|
	  "default" {line=token.beginLine; column=token.beginColumn;}
  )
  ":" stmts = Statements()

  { return new SwitchEntryStmt(line, column, token.endLine, token.endColumn,label, stmts); }
}

IfStmt IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
	Expression condition;
	Statement thenStmt;
	Statement elseStmt = null;
	int line;
	int column;
    Comment thenCmmt = null;
    Comment elseCmmt = null;
}
{
  "if" {line=token.beginLine; column=token.beginColumn;} "(" condition = Expression() ")" {} thenStmt = Statement() [ LOOKAHEAD(1) "else" {} elseStmt = Statement() ]
  {
      IfStmt tmp = new IfStmt(line, column, token.endLine, token.endColumn,condition, thenStmt, elseStmt);

      thenStmt.setComment(thenCmmt);
      if (elseStmt != null)
          elseStmt.setComment(elseCmmt);
      return tmp;
  }
}

WhileStmt WhileStatement():
{
	Expression condition;
	Statement body;
	int line;
	int column;
}
{
  "while" {line=token.beginLine; column=token.beginColumn;} "(" condition = Expression() ")" body = Statement()
  { return new WhileStmt(line, column, token.endLine, token.endColumn,condition, body); }
}

DoStmt DoStatement():
{
	Expression condition;
	Statement body;
	int line;
	int column;
}
{
  "do" {line=token.beginLine; column=token.beginColumn;} body = Statement() "while" "(" condition = Expression() ")" ";"
  { return new DoStmt(line, column, token.endLine, token.endColumn,body, condition); }
}

Statement ForStatement():
{
	String id = null;
	VariableDeclarationExpr varExpr = null;
	Expression expr = null;
	List init = null;
	List update = null;
	Statement body;
	int line;
	int column;
}
{
  "for" {line=token.beginLine; column=token.beginColumn;} "("

  (
      LOOKAHEAD(VariableDeclarationExpression() ":")
      varExpr = VariableDeclarationExpression() ":" expr = Expression()
    |
     [ init = ForInit() ] ";" [ expr = Expression() ] ";" [ update = ForUpdate() ]
  )

  ")" body = Statement()

  {
  	if (varExpr != null) {
  		return new ForeachStmt(line, column, token.endLine, token.endColumn,varExpr, expr, body);
  	}
	return new ForStmt(line, column, token.endLine, token.endColumn,init, expr, update, body);
  }
}

List ForInit():
{
	List ret;
	Expression expr;
}
{
  (
	  LOOKAHEAD( Modifiers() Type() <IDENTIFIER> )
	  expr = VariableDeclarationExpression() { ret = new LinkedList(); ret.add(expr); }
	|
	  ret = ExpressionList()
  )
  { return ret; }
}

List ExpressionList():
{
	List ret = new LinkedList();
	Expression expr;
}
{
  expr = Expression() { ret.add(expr); } ( "," expr = Expression()  { ret.add(expr); } )*

  { return ret; }
}

List ForUpdate():
{
	List ret;
}
{
  ret = ExpressionList()

  { return ret; }
}

BreakStmt BreakStatement():
{
	String id = null;
	int line;
	int column;
}
{
  "break" {line=token.beginLine; column=token.beginColumn;} [ <IDENTIFIER> { id = token.image; } ] ";"
  { return new BreakStmt(line, column, token.endLine, token.endColumn,id); }
}

ContinueStmt ContinueStatement():
{
	String id = null;
	int line;
	int column;
}
{
  "continue" {line=token.beginLine; column=token.beginColumn;} [ <IDENTIFIER> { id = token.image; } ] ";"
  { return new ContinueStmt(line, column, token.endLine, token.endColumn,id); }
}

ReturnStmt ReturnStatement():
{
	Expression expr = null;
	int line;
	int column;
}
{
  "return" {line=token.beginLine; column=token.beginColumn;} [ expr = Expression() ] ";"
  { return new ReturnStmt(line, column, token.endLine, token.endColumn,expr); }
}

ThrowStmt ThrowStatement():
{
	Expression expr;
	int line;
	int column;
}
{
  "throw" {line=token.beginLine; column=token.beginColumn;} expr = Expression() ";"
  { return new ThrowStmt(line, column, token.endLine, token.endColumn,expr); }
}

SynchronizedStmt SynchronizedStatement():
{
	Expression expr;
	BlockStmt block;
	int line;
	int column;
}
{
  "synchronized" {line=token.beginLine; column=token.beginColumn;} "(" expr = Expression() ")" block = Block()
  { return new SynchronizedStmt(line, column, token.endLine, token.endColumn,expr, block); }
}

TryStmt TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
	List resources = new LinkedList();
	BlockStmt tryBlock;
	BlockStmt finallyBlock = null;
	List catchs = null;
	Parameter except;
	BlockStmt catchBlock;
	Modifier exceptModifier;
	Type exceptType;
	List exceptTypes = new LinkedList();
	VariableDeclaratorId exceptId;
	int line;
	int column;
	int cLine;
	int cColumn;
	Type type;
}
{
  "try" {line=token.beginLine; column=token.beginColumn;}
  (resources = ResourceSpecification())?
  tryBlock = Block()
  (
        LOOKAHEAD(2)
  		(
  			"catch" {cLine=token.beginLine; cColumn=token.beginColumn;}
  			"("
  			exceptModifier = Modifiers() exceptType = Type() { exceptTypes.add(exceptType); }
  			( "|" exceptType = Type() { exceptTypes.add(exceptType); } )*
  			exceptId = VariableDeclaratorId()
  			")"

  			catchBlock = Block()
  			{
  			   if (exceptTypes.size() > 1) {
  			        type = new UnionType(exceptTypes);
  			   } else {
  			        type = (Type)exceptTypes.get(0);
  			   }
  			   catchs = add(catchs, new CatchClause(cLine, cColumn, token.endLine, token.endColumn, exceptModifier.modifiers, exceptModifier.annotations, type, exceptId, catchBlock));
  			   exceptTypes = new LinkedList(); }
  		)*
  		[ "finally" finallyBlock = Block() ]
  	|
  		"finally" finallyBlock = Block()
  )
  { return new TryStmt(line, column, token.endLine, token.endColumn, resources, tryBlock, catchs, finallyBlock); }
}


List ResourceSpecification() :
{
List vars;
}
{
  "("
  vars = Resources()
  (LOOKAHEAD(2) ";")?
  ")"
  { return vars; }
}


List Resources() :
{
	List vars = new LinkedList();
	VariableDeclarationExpr var;
}
 {
  /*this is a bit more lenient than we need to be, eg allowing access modifiers like private*/
  var = VariableDeclarationExpression() {vars.add(var);} (LOOKAHEAD(2) ";" var = VariableDeclarationExpression() {vars.add(var);})*
  { return vars; }
}


/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
   ">" ">" ">"
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
  ">" ">"
  )
}

/* Annotation syntax follows. */

AnnotationExpr Annotation():
{
	AnnotationExpr ret;
}
{
  (
	   LOOKAHEAD( "@" Name() "(" ( <IDENTIFIER> "=" | ")" ))
	   ret = NormalAnnotation()
	 |
	   LOOKAHEAD( "@" Name() "(" )
	   ret = SingleMemberAnnotation()
	 |
	   ret = MarkerAnnotation()
  )
  { return ret; }
}

NormalAnnotationExpr NormalAnnotation():
{
	NameExpr name;
	List pairs = null;
	int line;
	int column;
}
{
   "@" {line=token.beginLine; column=token.beginColumn;} name = Name() "(" [ pairs = MemberValuePairs() ] ")"
   { return new NormalAnnotationExpr(line, column, token.endLine, token.endColumn,name, pairs); }
}

MarkerAnnotationExpr MarkerAnnotation():
{
	NameExpr name;
	int line;
	int column;
}
{
  "@" {line=token.beginLine; column=token.beginColumn;} name = Name()
  { return new MarkerAnnotationExpr(line, column, token.endLine, token.endColumn,name); }
}

SingleMemberAnnotationExpr SingleMemberAnnotation():
{
	NameExpr name;
	Expression memberVal;
	int line;
	int column;
}
{
  "@" {line=token.beginLine; column=token.beginColumn;} name = Name() "(" memberVal = MemberValue() ")"
  { return new SingleMemberAnnotationExpr(line, column, token.endLine, token.endColumn,name, memberVal); }
}

List MemberValuePairs():
{
	List ret = new LinkedList();
	MemberValuePair pair;
}
{
   pair = MemberValuePair() { ret.add(pair); } ( "," pair = MemberValuePair() { ret.add(pair); } )*
   { return ret; }
}

MemberValuePair MemberValuePair():
{
	String name;
	Expression value;
	int line;
	int column;
}
{
    <IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn;} "=" value = MemberValue()
    { return new MemberValuePair(line, column, token.endLine, token.endColumn,name, value); }
}

Expression MemberValue():
{
	Expression ret;
	Type type;
}
{
  (
	   ret = Annotation()
	 |
	   ret = MemberValueArrayInitializer()
	 |
	   ret = ConditionalExpression() {
	     if (ret instanceof NameExpr) {
	       ret = new TypeExpr(ReferenceType.ofClass(((NameExpr)ret).getQualifiedName()));
	     }
	   }
	 |
	   ret = UiContainer()
  )
  { return ret; }
}

Expression  MemberValueArrayInitializer():
{
	List ret = new LinkedList();
	Expression member;
	int line;
	int column;
}
{
  "{" {line=token.beginLine; column=token.beginColumn;}
  (	member = MemberValue() { ret.add(member); } ( LOOKAHEAD(2) "," member = MemberValue() { ret.add(member); } )*  )? [ "," ]
  "}"
  { return new ArrayInitializerExpr(line, column, token.endLine, token.endColumn,ret); }
}


/* Annotation Types. */

AnnotationDeclaration AnnotationTypeDeclaration(Modifier modifier):
{
	NameExpr name;
	List members;
	int line = modifier.beginLine;
	int column = modifier.beginColumn;
}
{
  "@" { if (line == -1) {line=token.beginLine; column=token.beginColumn;} }
  "interface" name = Name() members = AnnotationTypeBody()

  {
      AnnotationDeclaration tmp = new AnnotationDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, null, members);
      tmp.setNameExpr(name);
      return tmp;
  }
}

List AnnotationTypeBody():
{
	List ret = null;
	BodyDeclaration member;
}
{
  "{" ( member = AnnotationBodyDeclaration() { ret = add(ret, member); } )* "}"

  { return ret; }
}

BodyDeclaration AnnotationBodyDeclaration():
{
   Modifier modifier;
   BodyDeclaration ret;
}
{
  {  }
  (
	";" { ret = new EmptyTypeDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
  |
    modifier = Modifiers()
    (
	   LOOKAHEAD(Type() <IDENTIFIER> "(")
	   ret = AnnotationTypeMemberDeclaration(modifier)
	  |
	   ret = ClassOrInterfaceDeclaration(modifier)
	  |
	   ret = EnumDeclaration(modifier)
	  |
	   ret = AnnotationTypeDeclaration(modifier)
	  |
	   ret = FieldDeclaration(modifier)
    )
  )
  { return ret; }
}

AnnotationMemberDeclaration AnnotationTypeMemberDeclaration(Modifier modifier):
{
	Type type;
	String name;
	Expression defaultVal = null;
}
{
  type = Type() <IDENTIFIER> { name = token.image; } "(" ")" [ defaultVal = DefaultValue() ] ";"

  {
    int line = modifier.beginLine;
    int column = modifier.beginColumn;
    { if (line == -1) {line=type.getBeginLine(); column=type.getBeginColumn();} }
    return new AnnotationMemberDeclaration(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, name, defaultVal);
  }
}

Expression DefaultValue():
{
	Expression ret;
}
{
  "default" ret = MemberValue()
  { return ret; }
}
