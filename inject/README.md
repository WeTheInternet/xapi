

The jre runtime takes a page out of the java.util.ServiceLoader playbook, and uses named files in the META-INF/ folders to bind interfaces (or classes!) to implementations.  Default jre uses META-INF/instances/fully.qualified.class.Name or META-INF/singletons/f.q.c.N resource files, with the implementation class inside.  The android layer uses assets/wti/instances and assets/wti/singletons respectively.  This location is set by a System property, and there is a generator to build these files for you automatically.

The jre runtime also supports runtime injection using org.reflections, provided the jars are on your classpath, and you have not disabled runtime injection with its controlling System property (see wetheinter.net.util.X_Properties for details).  Once the jre hotswapping module is ready, you will be able to inherit xapi-jre, and have org.reflections inherited automatically by maven.  Hotswapping will require control over class loaders, and may not be available on all platforms, thus, the default implementation class merely logs the lack of support to the console and quits.

It's also worth mentioning that the gwt version is kind enough to not ruin code splitting!  Our first prototype worked with just a plain gwt generator, but it had to access every service implementation class in one method (using class literals in switch statements, which is legal in jsni!); unfortunately this completely destroys any chance of code splitting.  Our current iteration uses "magic method injection" to turn each call to X_Inject.singleton() or .instance() into a new, generated method, thus preventing any form of cross-referencing and keeping the code splitter happy.  There are also auxiallary singleton provider methods which accept either a callback object, or a callback class literal, and they produce GWT.runAsync() boilerplate for you.  When you use callback classes, they are also injectable, so you can easily inject the service and the callback together, and do so safely in multiple locations without ever running the callback twice.  Finally, an injected callback also defers the instantiation of the callback until inside the new async block, thus preventing any leaked classes or fields used in your callback.

